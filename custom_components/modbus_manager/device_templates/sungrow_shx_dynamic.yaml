# Sungrow SHx Dynamic Template for Modbus Manager
# BASED ON: https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant

name: "Sungrow SH Series Inverter"
description: "Dynamic template for Sungrow SHx inverters. Supports all 36 SHx models: SHxK6, SHxK-20/V13, SHxK-30, SHx.0RS, SHx.0RT/RT-20/RT-V112/RT-V122, SHxT, MGxRL"
manufacturer: "Sungrow"
model: "SHx Series Dynamic"
version: 1.2.9
default_prefix: "SG"
default_slave_id: 1
type: "PV_Hybrid_Inverter"
firmware_version: "03011.95.01"

# Updated to Protocol Documentation V1.1.11 (2025-11-17)
# - Updated Battery Power to recommended register 5214-5215 (S32, 1W)
# - Updated Battery Current to recommended register 5631 (S16, 0.1A)
# - Confirmed Grid Frequency uses recommended register 5242 (U16, 0.01Hz)
# - Added Firmware Information registers (13250-13369)
# Updated Battery Power Limits (2026-01-08)
# - Added max_charge_power and max_discharge_power to dynamic_config for ALL models
# - SAFETY: Battery Power Control max_values set to LOWEST limit (6kW) for safety
# - Dynamic adjustment based on selected_model implemented in coordinator.py
# - Verified Limits from datasheets:
#   * SH3.0-6.0RS: 6.6kW/6.6kW (from datasheet V18)
#   * SH8.0/10RS: 10kW/10kW (from datasheet V2)
#   * SH5.0-10RT: 7.5kW/6kW to 10.6kW/10.6kW (from datasheet)
#   * SH5-25T: Estimated based on RT series scaling (not verified)
#   * MG5-6RL: Estimated based on RT series (not verified)
# - Runtime validation in number.py enforces safe limits based on battery capacity
# Updated Export Power and Battery Start Power Limits (2026-01-08)
# - Added max_ac_output_power to dynamic_config for ALL models
# - SAFETY: Battery Charging/Discharging Start Power max_value set to reasonable limit (3kW = 50% of smallest battery power)
# - Dynamic adjustment for all controls based on selected_model implemented in coordinator.py
# Updated Register Conditions (2026-02-05)
# - Added Protocol Version register (4952-4953, U32) with formatted calculated sensor (V1.1.7 format)
# - Firmware Information registers: Only available on RT/T/K6 models, not RS/MG models
# - Meter Channel 2 registers: Only available with DTSU666-20 meter AND not on RS/MG models
# - Battery capacity register: Only available on SH3.0-6.0RS, SH8.0-10RS, and SH5.0-10RT models
# - PV Power Limitation control: Only available on SHT models (SH5T-SH25T), not RT/RS models


# Dynamic configuration support
dynamic_config:

  valid_models:
    # SH3.0-6.0RS Series (Single Phase)
    # Battery Power Limits (from datasheet V18): max_charge_power (W), max_discharge_power (W)
    # AC Output Power Limits (from datasheet V18): max_ac_output_power (W)
    # All models: 6600W charge / 6600W discharge (30A max current)
    "SH3.0RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0xD17", max_charge_power: 6600, max_discharge_power: 6600, max_ac_output_power: 3000}
    "SH3.6RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0xD0D", max_charge_power: 6600, max_discharge_power: 6600, max_ac_output_power: 3680}
    "SH4.0RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0xD18", max_charge_power: 6600, max_discharge_power: 6600, max_ac_output_power: 4000}
    "SH5.0RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0xD0F", max_charge_power: 6600, max_discharge_power: 6600, max_ac_output_power: 5000}
    "SH6.0RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0xD10", max_charge_power: 6600, max_discharge_power: 6600, max_ac_output_power: 6000}

    # SH8.0-10RS Series (Single Phase, 4 MPPT)
    # Battery Power Limits (from datasheet V2): max_charge_power (W), max_discharge_power (W)
    # AC Output Power Limits (from datasheet V2): max_ac_output_power (W)
    # Both models: 10000W charge / 10000W discharge (50A max current)
    "SH8.0RS": {phases: 1, mppt_count: 4, string_count: 1, type_code: "0xD1A", max_charge_power: 10000, max_discharge_power: 10000, max_ac_output_power: 8000}
    "SH10RS": {phases: 1, mppt_count: 4, string_count: 1, type_code: "0xD1B", max_charge_power: 10000, max_discharge_power: 10000, max_ac_output_power: 10000}

    # SH5.0-10RT Series (Three Phase)
    # Battery Power Limits (from datasheet): max_charge_power (W), max_discharge_power (W)
    # AC Output Power Limits (from datasheet): max_ac_output_power (W)
    "SH5.0RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE00", max_charge_power: 7500, max_discharge_power: 6000, max_ac_output_power: 5000}
    "SH6.0RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE01", max_charge_power: 9000, max_discharge_power: 7200, max_ac_output_power: 6000}
    "SH8.0RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE02", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 8000}
    "SH10RT": {phases: 3, mppt_count: 2, string_count: 3, type_code: "0xE03", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 10000}
    "SH5.0RT-20": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE10", max_charge_power: 7500, max_discharge_power: 6000, max_ac_output_power: 5000}
    "SH6.0RT-20": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE11", max_charge_power: 9000, max_discharge_power: 7200, max_ac_output_power: 6000}
    "SH8.0RT-20": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE12", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 8000}
    "SH10RT-20": {phases: 3, mppt_count: 2, string_count: 3, type_code: "0xE13", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 10000}
    "SH5.0RT-V112": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE0C", max_charge_power: 7500, max_discharge_power: 6000, max_ac_output_power: 5000}
    "SH6.0RT-V112": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE0D", max_charge_power: 9000, max_discharge_power: 7200, max_ac_output_power: 6000}
    "SH8.0RT-V112": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE0E", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 8000}
    "SH10RT-V112": {phases: 3, mppt_count: 2, string_count: 3, type_code: "0xE0F", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 10000}
    "SH5.0RT-V122": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE08", max_charge_power: 7500, max_discharge_power: 6000, max_ac_output_power: 5000}
    "SH6.0RT-V122": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE09", max_charge_power: 9000, max_discharge_power: 7200, max_ac_output_power: 6000}
    "SH8.0RT-V122": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE0A", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 8000}
    "SH10RT-V122": {phases: 3, mppt_count: 2, string_count: 3, type_code: "0xE0B", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 10000}

    # SH5-25T Series (Three Phase)
    # Battery Power Limits: Using conservative estimates based on RT series scaling
    # AC Output Power Limits: Estimated based on model name (kW rating)
    # NOTE: Specific datasheet values not found - using safe estimates
    # SH5T-SH10T: Estimated similar to RT series
    # SH12T-SH25T: Estimated higher limits for larger models
    "SH5T": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0xE20", max_charge_power: 7500, max_discharge_power: 6000, max_ac_output_power: 5000}
    "SH6T": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0xE21", max_charge_power: 9000, max_discharge_power: 7200, max_ac_output_power: 6000}
    "SH8T": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0xE22", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 8000}
    "SH10T": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE23", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 10000}
    "SH12T": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0xE24", max_charge_power: 12000, max_discharge_power: 12000, max_ac_output_power: 12000}
    "SH15T": {phases: 3, mppt_count: 3, string_count: 2, type_code: "0xE25", max_charge_power: 15000, max_discharge_power: 15000, max_ac_output_power: 15000}
    "SH20T": {phases: 3, mppt_count: 3, string_count: 2, type_code: "0xE26", max_charge_power: 20000, max_discharge_power: 20000, max_ac_output_power: 20000}
    "SH25T": {phases: 3, mppt_count: 3, string_count: 2, type_code: "0xE28", max_charge_power: 25000, max_discharge_power: 25000, max_ac_output_power: 25000}

    # MG5-10RL Series (Three Phase) - Appendix 1
    "MG5RL": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0xD27", max_charge_power: 7500, max_discharge_power: 6000, max_ac_output_power: 5000}
    "MG6RL": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0xD28", max_charge_power: 9000, max_discharge_power: 7200, max_ac_output_power: 6000}
    "MG8RL": {phases: 3, mppt_count: 3, string_count: 1, type_code: "0xD29", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 8000}
    "MG10RL": {phases: 3, mppt_count: 3, string_count: 1, type_code: "0xD2A", max_charge_power: 10600, max_discharge_power: 10600, max_ac_output_power: 10000}

  firmware_version:
    description: "Firmware version string (e.g., '03011.95.01')"
    options: ["03011.95.01", "03011.95.10"]
    default: "03011.95.01"
    sensor_replacements:
      # Battery power sensor replacement (deprecated - now using recommended register 5214-5215)
      battery_power:
        "2.0.0":
          data_type: "int32"
          scale: 1
          swap: word
          description: "Battery power signed in firmware v2+"

  connection_type:
    description: "Connection type (LAN or WINET)"
    options: ["LAN", "WINET"]
    default: "LAN"

  meter_type:
    description: "Meter type connected to the inverter"
    options: ["None", "DTSU666", "DTSU666-20"]
    default: "DTSU666"
    # None: No smart meter connected - meter registers filtered out
    # DTSU666: Standard single-channel meter (registers 5600-5606, scale: 1)
    # DTSU666-20: Dual-channel meter with Channel 2 support (registers 5600-5606 + 13199-13205, scale: 1)
    # Meter Channel 2 sensors are only valid when DTSU666-20 is selected

  battery_config:
    description: "Battery configuration"
    options: ["none", "standard_battery", "sbr_battery"]
    default: "none"
    # Battery registers only passed through LAN port, not WINET - skip battery flow when WINET
    condition: "connection_type != 'WINET'"

# Base sensors (will be filtered based on configuration)
sensors:
  # Debug: Master/Slave mode raw (holding, read - mirror of controls for availability test)
  - name: Master Slave Mode
    unique_id: master_slave_mode
    address: 33499
    input_type: holding
    data_type: uint16
    scan_interval: 10
    group: "PV_device_info"
    entity_category: "diagnostic"
    map:
      170: "Enabled"   # 0xAA
      85: "Disabled"   # 0x55

  - name: Master Slave Role
    unique_id: master_slave_role
    address: 33500
    input_type: holding
    data_type: uint16
    scan_interval: 10
    group: "PV_device_info"
    entity_category: "diagnostic"
    map:
      160: "Master"    # 0xA0
      161: "Slave 1"   # 0xA1
      162: "Slave 2"   # 0xA2
      163: "Slave 3"   # 0xA3
      164: "Slave 4"   # 0xA4

  - name: Slave Count
    unique_id: slave_count
    address: 33501
    input_type: holding
    data_type: uint16
    precision: 0
    scan_interval: 10
    group: "PV_device_info"
    entity_category: "diagnostic"


  # Device Information
  - name: Inverter Serial
    unique_id: inverter_serial
    address: 4989 # reg 4990
    input_type: input
    data_type: string
    count: 10
    scan_interval: 600
    group: "PV_device_count"
    entity_category: "diagnostic"

  - name: Sungrow device type code
    unique_id: sungrow_device_type_code
    address: 4999 # reg 5000
    input_type: input
    data_type: uint16
    scan_interval: 600
    group: "PV_device_info"
    entity_category: "diagnostic"
    # Appendix 1: Device type codes (hex -> decimal)
    map:
      # SH3K6, SH4K6, SH5K-20, etc. (K6/30 series - not in Appendix 1)
      3334: "SH3K6"
      3335: "SH4K6"
      3337: "SH5K-20"
      3331: "SH5K-V13"
      3338: "SH3K6-30"
      3339: "SH4K6-30"
      3340: "SH5K-30"
      # SH3.0-6.0RS (0xD17, 0xD0D, 0xD18, 0xD0F, 0xD10)
      3351: "SH3.0RS"
      3341: "SH3.6RS"
      3352: "SH4.0RS"
      3343: "SH5.0RS"
      3344: "SH6.0RS"
      # SH8.0-10RS (0xD1A, 0xD1B)
      3354: "SH8.0RS"
      3355: "SH10RS"
      # SH5.0-10RT (0xE00-0xE03), RT-20 (0xE10-0xE13), V112 (0xE0C-0xE0F), V122 (0xE08-0xE0B)
      3584: "SH5.0RT"
      3585: "SH6.0RT"
      3586: "SH8.0RT"
      3587: "SH10RT"
      3600: "SH5.0RT-20"
      3601: "SH6.0RT-20"
      3602: "SH8.0RT-20"
      3603: "SH10RT-20"
      3596: "SH5.0RT-V112"
      3597: "SH6.0RT-V112"
      3598: "SH8.0RT-V112"
      3599: "SH10RT-V112"
      3592: "SH5.0RT-V122"
      3593: "SH6.0RT-V122"
      3594: "SH8.0RT-V122"
      3595: "SH10RT-V122"
      # SH5-25T (0xE20-0xE28)
      3616: "SH5T"
      3617: "SH6T"
      3618: "SH8T"
      3619: "SH10T"
      3620: "SH12T"
      3621: "SH15T"
      3622: "SH20T"
      3624: "SH25T"
      # MG5-10RL (0xD27, 0xD28, 0xD29, 0xD2A) - Appendix 1
      3367: "MG5RL"
      3368: "MG6RL"
      3369: "MG8RL"
      3370: "MG10RL"
    group: "PV_device_info"

  - name: Protocol version raw
    unique_id: protocol_version_raw
    address: 4951 # reg 4952-4953
    input_type: input
    data_type: uint32
    swap: word
    scan_interval: 30
    group: "PV_device_info"
    entity_category: "diagnostic"
    # Note: Format: 0x01010B00 = V1.1.11 (Major.Minor.Patch.Build)
    # For example, 0x01010700 represents the protocol version V1.1.7;
    # Forwarding via Logger is not supported.

  # Certification Versions (Protocol V1.1.11)
  - name: Certification version of ARM Software
    unique_id: certification_version_arm_software
    address: 4953 # reg 4954-4968 (15 bytes UTF-8 string)
    input_type: input
    data_type: string
    count: 15
    scan_interval: 3600
    group: "PV_device_info"
    icon: "mdi:certificate"
    entity_category: "diagnostic"
    # Certified version information after finalizing functions such as electrical, safety regulations, and standards for the whole machine

  - name: Certification version of DSP Software
    unique_id: certification_version_dsp_software
    address: 4968 # reg 4969-4983 (15 bytes UTF-8 string)
    input_type: input
    data_type: string
    count: 15
    scan_interval: 3600
    group: "PV_device_info"
    icon: "mdi:certificate"
    entity_category: "diagnostic"

  # Device Specifications (Protocol V1.1.11)
  - name: Nominal output power
    unique_id: nominal_output_power
    address: 5000 # reg 5001
    input_type: input
    data_type: uint16
    scale: 0.1
    precision: 1
    unit_of_measurement: kW
    device_class: "power"
    state_class: measurement
    scan_interval: 3600
    group: "PV_device_info"
    entity_category: "diagnostic"

  - name: Output type
    unique_id: output_type
    address: 5001 # reg 5002
    input_type: input
    data_type: uint16
    scan_interval: 3600
    group: "PV_device_info"
    entity_category: "diagnostic"
    # Protocol Table 3: 0=Single, 1=3P4L, 2=3P3L
    options:
      0: "Single"
      1: "3P4L"
      2: "3P3L"

  # Firmware Information (Protocol V1.1.11)
  # Note: Not available on SH3.0-10RS and MG5-10RL models
  - name: Inverter Firmware Info
    unique_id: inverter_firmware_info
    address: 13249 # reg 13250-13264 (15 bytes UTF-8 string)
    input_type: input
    data_type: string
    count: 15
    scan_interval: 3600
    group: "PV_device_info"
    icon: "mdi:chip"
    entity_category: "diagnostic"
    condition: "selected_model not in [SH3.0RS, SH3.6RS, SH4.0RS, SH5.0RS, SH6.0RS, SH8.0RS, SH10RS, MG5RL, MG6RL, MG8RL, MG10RL]"

  - name: Communication Module Firmware Info
    unique_id: communication_module_firmware_info
    address: 13264 # reg 13265-13279 (15 bytes UTF-8 string)
    input_type: input
    data_type: string
    count: 15
    scan_interval: 3600
    group: "PV_device_info"
    icon: "mdi:chip"
    entity_category: "diagnostic"
    condition: "selected_model not in [SH3.0RS, SH3.6RS, SH4.0RS, SH5.0RS, SH6.0RS, SH8.0RS, SH10RS, MG5RL, MG6RL, MG8RL, MG10RL]"

  - name: Battery Firmware Info
    unique_id: battery_firmware_info
    address: 13279 # reg 13280-13294 (15 bytes UTF-8 string)
    input_type: input
    data_type: string
    count: 15
    scan_interval: 3600
    group: "PV_device_info"
    icon: "mdi:chip"
    entity_category: "diagnostic"
    condition: "selected_model not in [SH3.0RS, SH3.6RS, SH4.0RS, SH5.0RS, SH6.0RS, SH8.0RS, SH10RS, MG5RL, MG6RL, MG8RL, MG10RL]"

  # Basic Inverter Data
  # Power generation of active output (including PV power generation and battery discharge)
  # How much AC has the Inverter generated today rom PV and Discharge today for consumption?
  - name: Daily PV generation & battery discharge
    unique_id: daily_pv_gen_battery_discharge
    address: 5002 # reg 5003
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total PV generation & battery discharge
    unique_id: total_pv_gen_battery_discharge
    address: 5003 # reg 5004
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: kWh
    precision: 1
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Inverter temperature
    unique_id: inverter_temperature
    address: 5007 # reg 5008
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: Â°C
    device_class: "temperature"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    group: "PV_temperature"

  # MPPT Data (will be filtered based on mppt_count)
  - name: MPPT1 voltage
    unique_id: mppt1_voltage
    address: 5010 # reg 5011
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT1 current
    unique_id: mppt1_current
    address: 5011 # reg 5012
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT2 voltage
    unique_id: mppt2_voltage
    address: 5012 # reg 5013
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT2 current
    unique_id: mppt2_current
    address: 5013 # reg 5014
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  # only for SH*T inverters with 3 MPPTs (will be filtered based on mppt_count)
  - name: MPPT3 voltage
    unique_id: mppt3_voltage
    address: 5014 # reg 5015
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT3 current
    unique_id: mppt3_current
    address: 5015 # reg 5016
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  # MPPT 4 (only SH8.0RS, SH10RS with 4 MPPTs per Protocol V1.1.11)
  - name: MPPT4 voltage
    unique_id: mppt4_voltage
    address: 5114 # reg 5115
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "selected_model in [SH8.0RS, SH10RS]"

  - name: MPPT4 current
    unique_id: mppt4_current
    address: 5115 # reg 5116
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "selected_model in [SH8.0RS, SH10RS]"

  - name: Total DC power
    unique_id: total_dc_power
    address: 5016 # reg 5017
    input_type: input
    data_type: uint32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_total_dc_power"

  # Phase Data (will be filtered based on phases)
  - name: Phase A voltage
    unique_id: phase_a_voltage
    address: 5018 # reg: 5019
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase B voltage
    unique_id: phase_b_voltage
    address: 5019 # reg: 5020
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase C voltage
    unique_id: phase_c_voltage
    address: 5020 # reg: 5021
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Reactive power
    unique_id: reactive_power
    address: 5032 # reg 5033
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    offset: 0
    scan_interval: 10
    group: "PV_power_measurement"
    entity_category: "diagnostic"

  - name: Power factor
    unique_id: power_factor
    address: 5034 # reg 5035
    input_type: input
    data_type: int16
    precision: 3
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: measurement
    scale: 0.001
    scan_interval: 10
    entity_category: "diagnostic"

  # Grid frequency: we use reg 5242 (address 5241) for higher precision 0.01Hz; reg 5036 (address 5035) has 0.1Hz only
  # - name: Grid frequency (0.1Hz)
  #   unique_id: grid_frequency_alt
  #   address: 5035 # reg 5036 - lower precision; prefer 5242 (address 5241)
  #   input_type: input
  #   data_type: uint16
  #   scale: 0.1
  #   unit_of_measurement: Hz

  - name: Grid frequency
    unique_id: grid_frequency
    address: 5241 # reg 5242 - RECOMMENDED: Higher precision (0.01Hz) than register 5036 (0.1Hz) per Protocol V1.1.11
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "Hz"
    device_class: "frequency"
    state_class: measurement
    scale: 0.01
    scan_interval: 10
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  # Meter Data (will be filtered based on phases and meter_type)
  # DTSU666 and DTSU666-20 use the same registers (5600-5606)
  # Note 1: Data related to the grid or load is only valid when the inverter is directly connected to a smart energy meter.
  # Registers 5603-5607 are valid only when a three-phase meter is connected.
  # These registers represent the power values of each phase (A, B, C).
  # Data is invalid for single - phase meters.

  - name: Meter active power raw
    unique_id: meter_active_power_raw
    address: 5600 # reg 5601
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    condition: "meter_type == 'DTSU666' or meter_type == 'DTSU666-20'"
    entity_category: "diagnostic"

  - name: Meter phase A active power raw
    unique_id: meter_phase_a_active_power_raw
    address: 5602 # reg 5603
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    condition: "(meter_type == 'DTSU666' or meter_type == 'DTSU666-20') and phases > 1"
    entity_category: "diagnostic"

  - name: Meter phase B active power raw
    unique_id: meter_phase_b_active_power_raw
    address: 5604 # reg 5605
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    condition: "(meter_type == 'DTSU666' or meter_type == 'DTSU666-20') and phases > 1"
    entity_category: "diagnostic"

  - name: Meter phase C active power raw
    unique_id: meter_phase_c_active_power_raw
    address: 5606 # reg 5607
    input_type: input
    data_type: int32
    count: 2
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    condition: "(meter_type == 'DTSU666' or meter_type == 'DTSU666-20') and phases > 1"
    entity_category: "diagnostic"

  # Meter Channel 2 Data (Protocol V1.1.11) - for DTSU666-20 dual-channel meter
  # NOTE: These sensors are only valid when DTSU666-20 is selected
  # They will show invalid values (0x7FFFFFFF) if no dual-channel meter is present
  - name: Meter Channel 2 Total Active Power raw
    unique_id: meter_channel_2_total_active_power_raw
    address: 13199 # reg 13200-13214 (S32, 1W)
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_meter_channel_2"
    condition: "meter_type == 'DTSU666-20' and selected_model not in [SH3.0RS, SH3.6RS, SH4.0RS, SH5.0RS, SH6.0RS, SH8.0RS, SH10RS, MG5RL, MG6RL]"
    entity_category: "diagnostic"

  - name: Meter Channel 2 Phase A Active Power raw
    unique_id: meter_channel_2_phase_a_active_power_raw
    address: 13201 # reg 13202-13215 (S32, 1W)
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_meter_channel_2"
    condition: "meter_type == 'DTSU666-20' and selected_model not in [SH3.0RS, SH3.6RS, SH4.0RS, SH5.0RS, SH6.0RS, SH8.0RS, SH10RS, MG5RL, MG6RL]"
    entity_category: "diagnostic"

  - name: Meter Channel 2 Phase B Active Power raw
    unique_id: meter_channel_2_phase_b_active_power_raw
    address: 13203 # reg 13204-13217 (S32, 1W)
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_meter_channel_2"
    condition: "meter_type == 'DTSU666-20' and selected_model not in [SH3.0RS, SH3.6RS, SH4.0RS, SH5.0RS, SH6.0RS, SH8.0RS, SH10RS, MG5RL, MG6RL]"
    entity_category: "diagnostic"

  - name: Meter Channel 2 Phase C Active Power raw
    unique_id: meter_channel_2_phase_c_active_power_raw
    address: 13205 # reg 13206-13219 (S32, 1W)
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_meter_channel_2"
    condition: "meter_type == 'DTSU666-20' and selected_model not in [SH3.0RS, SH3.6RS, SH4.0RS, SH5.0RS, SH6.0RS, SH8.0RS, SH10RS, MG5RL, MG6RL]"
    entity_category: "diagnostic"

  - name: BDC rated power
    unique_id: bdc_rated_power
    address: 5627 # reg 5628
    input_type: input
    data_type: uint16
    unit_of_measurement: "W"
    device_class: "power"
    state_class: measurement
    scale: 100
    scan_interval: 600
    entity_category: "diagnostic"

  - name: BMS max. charging current
    unique_id: bms_max_charging_current
    address: 5634 # reg 5635
    input_type: input
    data_type: uint16
    precision: 0
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 1
    scan_interval: 60
    entity_category: "diagnostic"

  - name: BMS max. discharging current
    unique_id: bms_max_discharging_current
    address: 5635 # reg 5636
    input_type: input
    data_type: uint16
    precision: 0
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 1
    scan_interval: 60
    entity_category: "diagnostic"

  - name: Battery capacity
    unique_id: battery_capacity
    address: 5638 # reg 5639 - High Precision version (0.01kWh precision) per Protocol V1.1.11
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: kWh
    device_class: "energy_storage"
    scale: 0.01
    scan_interval: 600
    entity_category: "diagnostic"
    condition: "selected_model in [SH3.0RS, SH3.6RS, SH4.0RS, SH5.0RS, SH6.0RS, SH8.0RS, SH10RS, SH5.0RT, SH6.0RT, SH8.0RT, SH10RT, SH5.0RT-20, SH6.0RT-20, SH8.0RT-20, SH10RT-20, SH5.0RT-V112, SH6.0RT-V112, SH8.0RT-V112, SH10RT-V112, SH5.0RT-V122, SH6.0RT-V122, SH8.0RT-V122, SH10RT-V122]"

  # Export Power Limitation Values (Protocol V1.1.11)
  - name: Min Export Power Limit Value
    unique_id: min_export_power_limit_value
    address: 5621 # reg 5622
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: kW
    device_class: "power"
    state_class: measurement
    scale: 0.01
    scan_interval: 60
    group: "PV_control"
    entity_category: "diagnostic"

  - name: Max Export Power Limit Value
    unique_id: max_export_power_limit_value
    address: 5622 # reg 5623
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: kW
    device_class: "power"
    state_class: measurement
    scale: 0.01
    scan_interval: 60
    group: "PV_control"
    entity_category: "diagnostic"

  # Backup Power (will be filtered based on battery_enabled and phases)
  - name: Backup phase A power
    unique_id: backup_phase_a_power
    address: 5722 # reg 5723
    input_type: input
    data_type: int16
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Backup phase B power
    unique_id: backup_phase_b_power
    address: 5723 # reg 5724
    input_type: input
    data_type: int16
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Backup phase C power
    unique_id: backup_phase_c_power
    address: 5724 # reg 5725
    input_type: input
    data_type: int16
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Total backup power
    unique_id: total_backup_power
    address: 5725 # reg 5726
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10

  # Backup port current, voltage, frequency (off-grid/backup monitoring per Protocol V1.1.11)
  - name: Backup phase A current
    unique_id: backup_phase_a_current
    address: 5719 # reg 5720
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "battery_enabled == true"

  - name: Backup phase B current
    unique_id: backup_phase_b_current
    address: 5720 # reg 5721
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "battery_enabled == true and phases > 1"

  - name: Backup phase C current
    unique_id: backup_phase_c_current
    address: 5721 # reg 5722
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "battery_enabled == true and phases > 1"

  - name: Backup phase A voltage
    unique_id: backup_phase_a_voltage
    address: 5730 # reg 5731
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "battery_enabled == true"

  - name: Backup phase B voltage
    unique_id: backup_phase_b_voltage
    address: 5731 # reg 5732
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "battery_enabled == true and phases > 1"

  - name: Backup phase C voltage
    unique_id: backup_phase_c_voltage
    address: 5732 # reg 5733
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "battery_enabled == true and phases > 1"

  - name: Backup frequency
    unique_id: backup_frequency
    address: 5733 # reg 5734
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: Hz
    device_class: "frequency"
    state_class: measurement
    scale: 0.01
    scan_interval: 10
    condition: "battery_enabled == true"

  # Meter Phase Data (will be filtered based on phases)
  - name: Meter phase A voltage
    unique_id: meter_phase_a_voltage
    address: 5740 # reg 5741
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Meter phase B voltage
    unique_id: meter_phase_b_voltage
    address: 5741 # reg 5742
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Meter phase C voltage
    unique_id: meter_phase_c_voltage
    address: 5742 # reg 5743
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Meter phase A current
    unique_id: meter_phase_a_current
    address: 5743 # reg 5744
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 10

  - name: Meter phase B current
    unique_id: meter_phase_b_current
    address: 5744 # reg 5745
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 10

  - name: Meter phase C current
    unique_id: meter_phase_c_current
    address: 5745 # reg 5746
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 10

  # following statistic sensors only work on some SH*RT inverters
  # (only LAN attached devices)
  # Therefore commenting them here
  # # Start monthly PV generation
  - name: Monthly PV generation (01 January)
    unique_id: monthly_pv_generation_01_january
    address: 6226 # reg 6227
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    condition: "connection_type == 'LAN'"
    entity_category: "diagnostic"

  - name: Monthly PV generation (02 February)
    unique_id: monthly_pv_generation_02_february
    condition: "connection_type == 'LAN'"
    address: 6227 # reg 6228
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (03 March)
    unique_id: monthly_pv_generation_03_march
    condition: "connection_type == 'LAN'"
    address: 6228 # reg 6229
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (04 April)
    unique_id: monthly_pv_generation_04_april
    condition: "connection_type == 'LAN'"
    address: 6229 # reg 6230
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (05 May)
    unique_id: monthly_pv_generation_05_may
    condition: "connection_type == 'LAN'"
    address: 6230 # reg 6231
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (06 June)
    unique_id: monthly_pv_generation_06_june
    condition: "connection_type == 'LAN'"
    address: 6231 # reg 6232
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (07 July)
    unique_id: monthly_pv_generation_07_july
    condition: "connection_type == 'LAN'"
    address: 6232 # reg 6233
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (08 August)
    unique_id: monthly_pv_generation_08_august
    condition: "connection_type == 'LAN'"
    address: 6233 # reg 6234
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (09 September)
    unique_id: monthly_pv_generation_09_september
    condition: "connection_type == 'LAN'"
    address: 6234 # reg 6235
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (10 October)
    unique_id: monthly_pv_generation_10_october
    condition: "connection_type == 'LAN'"
    address: 6235 # reg 6236
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (11 November)
    unique_id: monthly_pv_generation_11_november
    condition: "connection_type == 'LAN'"
    address: 6236 # reg 6237
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly PV generation (12 December)
    unique_id: monthly_pv_generation_12_december
    condition: "connection_type == 'LAN'"
    address: 6237 # reg 6238
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"
  # End monthly PV generation

  # Start yearly pv generation
  - name: Yearly PV generation (2019)
    unique_id: yearly_pv_generation_2019
    condition: "connection_type == 'LAN'"
    address: 6257 # reg 6258
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2020)
    unique_id: yearly_pv_generation_2020
    condition: "connection_type == 'LAN'"
    address: 6259 # reg 6260
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2021)
    unique_id: yearly_pv_generation_2021
    condition: "connection_type == 'LAN'"
    address: 6261 # reg 6262
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2022)
    unique_id: yearly_pv_generation_2022
    condition: "connection_type == 'LAN'"
    address: 6263 # reg 6264
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2023)
    unique_id: yearly_pv_generation_2023
    condition: "connection_type == 'LAN'"
    address: 6265 # reg 6266
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2024)
    unique_id: yearly_pv_generation_2024
    condition: "connection_type == 'LAN'"
    address: 6267 # reg 6268
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2025)
    unique_id: yearly_pv_generation_2025
    condition: "connection_type == 'LAN'"
    address: 6269 # reg 6270
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2026)
    unique_id: yearly_pv_generation_2026
    condition: "connection_type == 'LAN'"
    address: 6271 # reg 6272
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2027)
    unique_id: yearly_pv_generation_2027
    condition: "connection_type == 'LAN'"
    address: 6273 # reg 6274
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2028)
    unique_id: yearly_pv_generation_2028
    condition: "connection_type == 'LAN'"
    address: 6275 # reg 6276
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly PV generation (2029)
    unique_id: yearly_pv_generation_2029e
    condition: "connection_type == 'LAN'"
    address: 6277 # reg 6278
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"
  # End yearly pv generation

  # Start monthly export
  - name: Monthly export (01 January)
    unique_id: monthly_export_01_january
    condition: "connection_type == 'LAN'"
    address: 6595 # reg 6596
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (02 February)
    unique_id: monthly_export_02_february
    condition: "connection_type == 'LAN'"
    address: 6596 # reg 6597
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (03 March)
    unique_id: monthly_export_03_march
    condition: "connection_type == 'LAN'"
    address: 6597 # reg 6598
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (04 April)
    unique_id: monthly_export_04_april
    condition: "connection_type == 'LAN'"
    address: 6598 # reg 6599
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (05 May)
    unique_id: monthly_export_05_may
    condition: "connection_type == 'LAN'"
    address: 6599 # reg 6600
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (06 June)
    unique_id: monthly_export_06_june
    condition: "connection_type == 'LAN'"
    address: 6600 # reg 6601
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (07 July)
    unique_id: monthly_export_07_july
    condition: "connection_type == 'LAN'"
    address: 6601 # reg 6602
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (08 August)
    unique_id: monthly_export_08_august
    condition: "connection_type == 'LAN'"
    address: 6602 # reg 6603
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (09 September)
    unique_id: monthly_export_09_september
    condition: "connection_type == 'LAN'"
    address: 6603 # reg 6604
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (10 October)
    unique_id: monthly_export_10_october
    condition: "connection_type == 'LAN'"
    address: 6604 # reg 6605
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (11 November)
    unique_id: monthly_export_11_november
    condition: "connection_type == 'LAN'"
    address: 6605 # reg 6606
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Monthly export (12 December)
    unique_id: monthly_export_12_december
    condition: "connection_type == 'LAN'"
    address: 6606 # reg 6607
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"
  # End monthly export

  # Start yearly export energy from PV
  - name: Yearly Export (2019)
    unique_id: yearly_export_2019
    condition: "connection_type == 'LAN'"
    address: 6615 # reg 6616
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2020)
    unique_id: yearly_export_2020
    condition: "connection_type == 'LAN'"
    address: 6617 # reg 6618
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2021)
    unique_id: yearly_export_2021
    condition: "connection_type == 'LAN'"
    address: 6619 # reg 6620
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2022)
    unique_id: yearly_export_2022
    condition: "connection_type == 'LAN'"
    address: 6621 # reg 6622
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2023)
    unique_id: yearly_export_2023
    condition: "connection_type == 'LAN'"
    address: 6623 # reg 6624
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2024)
    unique_id: yearly_export_2024
    condition: "connection_type == 'LAN'"
    address: 6625 # reg 6626
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2025)
    unique_id: yearly_export_2025
    condition: "connection_type == 'LAN'"
    address: 6627 # reg 6628
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2026)
    unique_id: yearly_export_2026
    condition: "connection_type == 'LAN'"
    address: 6629 # reg 6630
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2027)
    unique_id: yearly_export_2027
    condition: "connection_type == 'LAN'"
    address: 6631 # reg 6632
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"

  - name: Yearly Export (2028)
    unique_id: yearly_export_2028
    condition: "connection_type == 'LAN'"
    address: 6633 # reg 6634
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    entity_category: "diagnostic"
  # # End yearly export energy from PV


  # System state and status sensors
  - name: "System state"
    unique_id: "system_state"
    address: 12999
    input_type: "input"
    data_type: "uint16"
    scan_interval: 10
    # Appendix 2: Running State
    options:
      # Running states (power generation)
      0x0000: "Running (On-grid)"
      0x0040: "Running (On-grid)"
      0x0014: "Microgrid Operation"
      0x0041: "Off-grid Charge"
      0x0400: "Running in maintain mode"
      0x0800: "Running in compulsory mode"
      0x1000: "Running (Off-grid)"
      0x4000: "Running in External EMS mode"
      0x4001: "Emergency Charging Operation"
      0x8100: "Derating Running"
      0x0080: "Derating Running"
      0x8200: "Dispatch Running"
      0x9100: "Warn Running"
      # Stop/standby states (no power generation)
      0x8000: "Stop"
      0x0001: "Stop"
      0x1300: "Key stop"
      0x0002: "Key stop"
      0x1500: "Emergency Stop"
      0x0004: "Emergency Stop"
      0x1400: "Standby"
      0x0008: "Standby"
      0x1200: "Initial standby"
      0x0010: "Initial standby"
      0x1600: "Starting"
      0x0020: "Starting"
      0x1111: "Uninitialized"
      0x0200: "Update Failed"
      0x2500: "Communicate fault"
      0x2501: "Restarting"
      0x5500: "Fault"
      0x0100: "Fault"
      0x1700: "AFCI self-test shutdown"
      0x1800: "Intelligent Station Building Status"
      0x1900: "Safe Mode"
      0x2000: "Open loop"
    group: "PV_status"

  - name: "Running state"
    unique_id: "running_state"
    address: 13000
    input_type: input
    data_type: uint16
    precision: 0
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_status"
    # Appendix 3: Power Flow State (bit position = key)
    flags:
      0: "PV Generating"
      1: "Battery charging"
      2: "Battery discharging"
      3: "Positive load power"
      4: "Exporting power to grid"
      5: "Importing power from grid"
      7: "Negative load power"


  - name: "Load Adjustment Mode Raw"
    unique_id: "load_adjustment_mode_selection_raw"
    address: 13001
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 10
    state_class: measurement
    # Appendix 5: Load Control Mode
    options:
      0: "Timing mode"
      1: "ON/OFF mode"
      2: "Power optimized mode"
      3: "Disable"
    group: "PV_modes"

  # Energy and power sensors
  - name: Daily PV generation
    unique_id: daily_pv_generation
    address: 13001 # reg 13002
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total PV generation
    unique_id: total_pv_generation
    address: 13002 # reg 13003
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Daily exported energy from PV
    unique_id: daily_exported_energy_from_PV
    address: 13004 # reg 13005
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Total exported energy from PV
    unique_id: total_exported_energy_from_pv
    address: 13005 # reg 13006
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  # Power consumed by loads
  - name: Load power
    unique_id: load_power
    address: 13007 # reg 13008
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  # Power delivered by the inverter to the grid
  - name: Export power raw
    unique_id: export_power_raw
    address: 13009 # reg 13010
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Load Adjustment Mode ON/OFF Selection raw
    unique_id: load_adjustment_mode_on_off_selection_raw
    address: 13010 # reg 13011
    input_type: holding
    data_type: uint16
    scan_interval: 10
    state_class: measurement
    # Parameter Setting Table 4: Load ON/OFF mode - 0xAA=ON, 0x55=OFF
    options:
      0xAA: "ON"
      0x55: "OFF"

  # Battery sensors (will be filtered based on battery_enabled)
  - name: Daily battery charge from PV
    unique_id: daily_battery_charge_from_pv
    address: 13011 # reg 13012
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total battery charge from PV
    unique_id: total_battery_charge_from_pv
    address: 13012 # reg 13013
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Daily direct energy consumption
    unique_id: daily_direct_energy_consumption
    address: 13016 # reg 13017
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total direct energy consumption
    unique_id: total_direct_energy_consumption
    address: 13017 # reg 13018 (Input register - different from holding register 13017 used for control)
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Battery voltage
    unique_id: battery_voltage
    address: 13019 # reg 13020
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Battery current
    unique_id: battery_current
    address: 5630 # reg 5631 - RECOMMENDED: Per Protocol V1.1.11, register 5631 is recommended instead of 13021
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    state_class: measurement
    device_class: "current"
    scale: 0.1
    scan_interval: 10

  - name: Battery power
    unique_id: battery_power
    address: 5213 # reg 5214-5215 - RECOMMENDED: Per Protocol V1.1.11, register 5214-5215 (S32) is recommended instead of 13022 (S16)
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_battery_power"
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Battery level
    unique_id: battery_level
    address: 13022 # reg 13023
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "%"
    device_class: "battery"
    state_class: measurement
    scale: 0.1
    scan_interval: 60
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Battery state of health
    unique_id: battery_state_of_health
    address: 13023 # reg 13024
    input_type: input
    data_type: uint16
    precision: 0
    unit_of_measurement: "%"
    state_class: measurement
    scale: 0.1
    scan_interval: 600

  - name: Battery temperature
    unique_id: battery_temperature
    address: 13024 # reg 13025
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: Â°C
    device_class: "temperature"
    state_class: measurement
    scale: 0.1
    scan_interval: 60
    group: "PV_battery_temperature"

  - name: Daily battery discharge
    unique_id: daily_battery_discharge
    address: 13025 # reg 13026
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total battery discharge
    unique_id: total_battery_discharge
    address: 13026 # reg 13027
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Self-consumption of today
    unique_id: self_consumption_of_today
    address: 13028 # reg 13029
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "%"
    state_class: measurement
    scale: 0.1
    scan_interval: 600

  # Commented out for now as not clear if useful for us
  #- name: DRM State
  #  unique_id: drm_state
  #  address: 13042 # reg 13043
  #  input_type: input
  #  data_type: uint16
  #  scan_interval: 60
  #  entity_category: "diagnostic"
  #  # Protocol Table 3: 1-9 = DRM0-DRM8; other = Invalid
  #  options:
  #    1: "DRM0"
  #    2: "DRM1"
  #    3: "DRM2"
  #    4: "DRM3"
  #    5: "DRM4"
  #    6: "DRM5"
  #    7: "DRM6"
  #    8: "DRM7"
  #    9: "DRM8"

  # Phase current sensors (will be filtered based on phases)
  - name: Phase A current
    unique_id: phase_a_current
    address: 13030 # reg 13031
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase B current
    unique_id: phase_b_current
    address: 13031 # reg 13032
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase C current
    unique_id: phase_c_current
    address: 13032 # reg 13033
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Total active power
    unique_id: total_active_power
    address: 13033 # reg 13034
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Daily imported energy
    unique_id: daily_imported_energy
    address: 13035 # reg 13036
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Total imported energy
    unique_id: total_imported_energy
    address: 13036 # reg 13037
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"
    entity_category: "diagnostic"

  - name: Daily battery charge
    unique_id: daily_battery_charge
    address: 13039 # reg 13040
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total battery charge
    unique_id: total_battery_charge
    address: 13040 # reg 13041
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Daily exported energy
    unique_id: daily_exported_energy
    address: 13044 # reg 13045
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total_increasing
    scale: 0.1
    scan_interval: 60
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Total exported energy
    unique_id: total_exported_energy
    address: 13045 # reg 13046
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: total
    scale: 0.1
    scan_interval: 600
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  # --- COMMENTED OUT: Fault/Diagnostic registers (Protocol V1.1.11 Appendix 4) - uncomment for diagnostics ---
  # Bit-based fault analysis; flags key = bit position
  # - name: Inverter alarm
  #   unique_id: inverter_alarm_raw
  #   address: 13049 # reg 13050-13051 U32
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   flags:
  #     0: "Fan Alarm"
  #     1: "Lightning Protection Alarm on AC Side"
  #     2: "Lightning Protection Alarm on DC Side"
  #     3: "Bypass Switch Abnormal"
  #     4: "Communication Alarm"
  #     5: "Parallel Communication Alarm"
  #     6: "Device Abnormality"
  #     7: "Junction Box leakage Protector Alarm"
  #     8: "PV1 Abnormal Warn"
  #     9: "PV2 Abnormal Warn"
  #     10: "PV3 Abnormal Warn"
  #     11: "PV4 Abnormal Warn"
  #     12: "Fan 2 Rotate Low Speed Alarm"
  #     13: "Fan 2 Stall Alarm"
  #     14: "Meter input/output ports reversed or wrong terminals"
  #     15: "Software Version Mismatch"
  #     16: "SPD or Fuse Alarm"
  #     17: "FRAM Read Alarm"
  #     18: "SPI Com Alarm"
  #     19: "Ambient Temperature Sensor Open Circuit Alarm"
  #     20: "Ambient Temperature Sensor Short Circuit Alarm"
  #     21: "Inversion T Sensor Open Circuit Alarm"
  #     22: "Inversion T Sensor Short Circuit Alarm"
  #     23: "Boost T Sensor Open Circuit Alarm"
  #     24: "Boost T Sensor Short Circuit Alarm"
  #     25: "Input Cfg Alarm In DC Source Mode Or Clock Reset Abnormal"
  #     26: "PV HV Flt"
  #     27: "Ambient Low Temperature Sensor Open Circuit Alarm"
  #     28: "Fan 1 Low Rotation Speed Alarm"
  #     29: "Fan 1 Stall Alarm"
  #     30: "Meter Communication Alarm"
  #     31: "BOOST Short Circuit Alarm"
  # - name: Grid-side fault
  #   unique_id: grid_side_fault_raw
  #   address: 13051 # reg 13052-13053 U32
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   flags:
  #     0: "Grid Overvoltage"
  #     1: "Grid Transient V-over"
  #     2: "Grid Under-voltage"
  #     3: "Grid V-low"
  #     5: "AC C-over"
  #     6: "Grid Over-frequency"
  #     7: "Grid Under-frequency"
  #     8: "Grid Power Outage"
  #     9: "Device Abnormality"
  #     10: "Excessive Leakage Current"
  #     11: "Grid Abnormal"
  #     12: "10 Minutes Grid Overvoltage"
  #     13: "High Grid Voltage"
  #     14: "Output Overload"
  #     15: "Grid Voltage Imbalance"
  #     16: "Inversion C-over Hardware Flt"
  #     17: "High Grid Frequency"
  #     18: "Grid F-low"
  #     19: "V-Grid Uniform Fault"
  #     20: "Grid Frequency Uniform Fault"
  #     21: "Network Side Protection Self-test Failed"
  #     22: "Grounding Cable Fault"
  #     23: "Inversion V DC Ject V-over Flt"
  #     24: "AC Side Under-voltage"
  #     25: "AC Side Overvoltage"
  #     26: "AC Side Under-frequency"
  #     27: "AC Side Over-frequency"
  #     28: "Vac Unbal"
  #     29: "Bypass Instantaneous Overcurrent"
  #     30: "Bypass Switch Over Current"
  # - name: System fault 1
  #   unique_id: system_fault_1_raw
  #   address: 13053 # reg 13054-13055 U32
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   flags:
  #     0: "Inversion Switch Tube Over-temperature"
  #     1: "BOOST Switch Tube T-over"
  #     2: "PV IR Flt"
  #     3: "Bypass Switch Fault"
  #     4: "EPS Relay Failure"
  #     5: "Junction Box Relay Fault"
  #     6: "Input and Output Mismatch Fault"
  #     7: "PV HV P-over Alarm or Prot"
  #     8: "Redundancy Fault"
  #     9: "R-phase inverter voltage sampling channel abnormal"
  #     10: "S-phase inverter voltage sampling channel abnormal"
  #     11: "T-phase inverter voltage sampling channel abnormal"
  #     12: "R-phase DC component sampling channel abnormal"
  #     13: "S-phase DC component sampling channel abnormal"
  #     14: "T-phase DC component sampling channel abnormal"
  #     15: "PV 1 current sampling channel abnormal"
  #     16: "PV 2 current sampling channel abnormal"
  #     17: "PV 1 MPPT current sampling channel abnormal"
  #     18: "PV 2 MPPT current sampling channel abnormal"
  #     19: "Control Board Power Supply Under-voltage Fault"
  #     20: "Leak Current CT Self-detection Fault"
  #     21: "SPI Com Flt"
  #     22: "LCD and Main DSP Communication Fault"
  #     24: "PV3 current sampling channel failure"
  #     25: "N-wire current sampling channel abnormal"
  #     26: "Balance bridge current sampling channel abnormal"
  # - name: System fault 2
  #   unique_id: system_fault_2_raw
  #   address: 13055 # reg 13056-13057 U32
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   flags:
  #     0: "Module Over-temperature"
  #     1: "Excessively High Ambient Temperature"
  #     2: "Device Abnormality"
  #     3: "Low System Insulation Resistance"
  #     7: "Low Ambient Temperature"
  #     11: "Input Configuration Abnormality"
  #     15: "Backup Load Overpower Fault"
  # - name: DC-side fault
  #   unique_id: dc_side_fault_raw
  #   address: 13057 # reg 13058-13059 U32
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   flags:
  #     4: "PV Access Failure"
  #     9: "PV1 Reverse Connection Fault"
  #     10: "PV2 Reverse Connection Fault"
  #     16: "Bus Overvoltage Hardware Fault"
  #     17: "Busbar Average Under-voltage"
  #     18: "PV Hardware Overcurrent Fault"
  #     19: "PV Voltage Exceeds Bus Voltage"
  #     20: "BOOST1 Short Circuit Fault"
  #     21: "BOOST2 Short Circuit Fault"
  #     22: "DC C-over"
  #     23: "PV3 Overcurrent"
  #     24: "PV3 Reverse Connection Fault"
  #     25: "BOOST3 short circuit fault"
  #     26: "Half-bus overvoltage hardware fault"
  #     27: "Balance bridge overcurrent hardware fault"
  #     28: "PV4 Reverse Connection Fault"
  # - name: Permanent fault
  #   unique_id: permanent_fault_raw
  #   address: 13059 # reg 13060-13061 U32
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   flags:
  #     0: "PV Overcurrent Permanent Fault"
  #     1: "Inversion Overcurrent Permanent Fault"
  #     2: "High DC Injection Permanent Fault"
  #     3: "Bus V-over Perm. Flt"
  #     4: "Relay Perm Fault"
  #     5: "PV1 Self-check Permanent Fault"
  #     6: "PV2 Self-check Permanent Fault"
  #     7: "Inversion Open-loop Self-detection Perm. Flt"
  #     8: "Entire Temperature Sensor Failure"
  #     9: "BOOST3 open-loop self-check permanent fault"
  #     10: "Balance bridge overcurrent permanent fault"
  #     11: "Half-bus overvoltage permanent fault"
  # - name: BDC-side fault
  #   unique_id: bdc_side_fault_raw
  #   address: 13061 # reg 13062-13063 U32
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   flags:
  #     0: "BDC Charge Transient I-over"
  #     1: "BDC Discharge Transient I-over"
  #     2: "Clamping Capacitance V-low Fault"
  #     3: "Clamping Capacitance Transient V-over"
  #     5: "Battery Pre-charge Relay Failure"
  #     8: "BDC Self-detect Flt"
  #     12: "BDC T-over Flt"
  #     16: "BDC Hardware I-over"
  #     20: "BDC Current Sampling Channel Abnormality"
  #     22: "Leakage Current Sampling Channel Abnormality"
  #     23: "Secondary DSP Communication Fault"
  #     24: "BDC Soft Start Flt"
  # - name: BDC-side permanent fault
  #   unique_id: bdc_side_permanent_fault_raw
  #   address: 13063 # reg 13064-13065 U32
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   flags:
  #     0: "BDC I-over Perm. Flt"
  #     2: "Battery Overvoltage Permanent Fault"
  #     4: "BDC Self-detect Permanent Flt"
  #     7: "BDC Soft Start Perm. Flt"
  - name: Battery fault
    unique_id: battery_fault_raw
    address: 13065 # reg 13066-13067 U32
    input_type: input
    data_type: uint32
    swap: word
    entity_category: diagnostic
    condition: "battery_enabled == true"
    flags:
      3: "Battery Average Under-voltage Fault"
      7: "Battery Over-temperature Fault"
      8: "Battery Low Temperature Fault"
      11: "Battery Transient Overvoltage"
      12: "Battery Average Overvoltage Fault"
      14: "BMS Communication Fault"
      15: "Battery Hardware Overvoltage"
      16: "Abnormal Battery Connection (Reversed Polarity)"
      17: "BMS and Battery Fault"
  - name: Battery alarm
    unique_id: battery_alarm_raw
    address: 13067 # reg 13068-13069 U32
    input_type: input
    data_type: uint32
    swap: word
    entity_category: diagnostic
    condition: "battery_enabled == true"
    flags:
      0: "BDC T Sensor Open Circuit Alarm"
      1: "BDC T Sensor Short Circuit Alarm"
  - name: BMS alarm
    unique_id: bms_alarm_raw
    address: 13069 # reg 13070-13071 U32 - requires battery Modbus address
    input_type: input
    data_type: uint32
    swap: word
    entity_category: diagnostic
    condition: "battery_enabled == true"
    flags:
      0: "Overvoltage Alarm"
      1: "Over-temperature Alarm"
      2: "Low Temperature Alarm"
      3: "Charge/Discharge Overcurrent Alarm"
      5: "Battery Voltage Unbalance"
      7: "Under-voltage Alarm"
      8: "Abnormal SD Card"
      9: "Cell Voltage Imbalance Alarm"
      10: "Cell Temperature Difference Alarm"
      11: "Battery Module Inconsistency Alarm"
      12: "Mixed Cell Alarm"
  - name: BMS protection
    unique_id: bms_protection_raw
    address: 13071 # reg 13072-13073 U32 - requires battery Modbus address
    input_type: input
    data_type: uint32
    swap: word
    entity_category: diagnostic
    condition: "battery_enabled == true"
    flags:
      0: "Overvoltage Protection"
      1: "Over-temperature Protection"
      2: "Low Temperature Protection"
      3: "Charge/Discharge Overcurrent Protection"
      4: "Over Charge Power Limit Fault"
      5: "Over Discharge Power Limit Fault"
      7: "Low Voltage Protection"
      8: "Slave Battery Fault"
      9: "Pre-Charge Failed"
      10: "Abnormal External Power Line Status"
      11: "Current Sampling Fault"
      12: "Temperature Sampling Fault"
      13: "Voltage Sampling Fault"
      14: "Battery Internal Communication Failure"
      15: "DC Contactor Failure"
  - name: BMS fault 1
    unique_id: bms_fault_1_raw
    address: 13073 # reg 13074-13075 U32 - requires battery Modbus address; note Holding 13073=Export Limit
    input_type: input
    data_type: uint32
    swap: word
    entity_category: diagnostic
    condition: "battery_enabled == true"
    flags:
      0: "FET Failure/Battery Switch Failure"
      1: "Failure in Battery Internal Hardware"
      2: "Overcurrent Fault"
      3: "Battery Short Circuit Fault"
      4: "Internal Communication Fault"
      5: "Input Overvoltage"
      7: "Software Version Mismatch Fault"
      8: "Heating Alarm"
      9: "Heating Circuit Abnormal"
      12: "Battery Self-test Fault"

  # - name: BMS fault 2
  #   unique_id: bms_fault_2_raw
  #   address: 13075 # reg 13076-13077 U32 - requires battery Modbus address
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   condition: "battery_enabled == true"
  #   # Bit0-Bit31 Reserved per Appendix 4
  # - name: BMS alarm 2
  #   unique_id: bms_alarm_2_raw
  #   address: 13077 # reg 13078-13079 U32 - requires battery Modbus address
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   entity_category: diagnostic
  #   condition: "battery_enabled == true"
  #   flags:
  #     0: "BMS Internal Alarm"

  # --- COMMENTED OUT: System clock (Holding 4999-5004) ---
  # - name: System clock year
  #   unique_id: system_clock_year
  #   address: 4999
  #   input_type: holding
  #   data_type: uint16
  # - name: System clock month
  #   unique_id: system_clock_month
  #   address: 5000
  #   input_type: holding
  #   data_type: uint16
  # - name: System clock day
  #   unique_id: system_clock_day
  #   address: 5001
  #   input_type: holding
  #   data_type: uint16
  # - name: System clock hour
  #   unique_id: system_clock_hour
  #   address: 5002
  #   input_type: holding
  #   data_type: uint16
  # - name: System clock minute
  #   unique_id: system_clock_minute
  #   address: 5003
  #   input_type: holding
  #   data_type: uint16
  # - name: System clock second
  #   unique_id: system_clock_second
  #   address: 5004
  #   input_type: holding
  #   data_type: uint16

  # --- COMMENTED OUT: DO Configuration (reg 13001, address 13000) - 0: Off, 1: Load Control, 2: Grounding Fault, 3: Micro Grid ---
  # - name: DO Configuration raw
  #   unique_id: do_configuration_raw
  #   address: 13000
  #   input_type: holding
  #   data_type: uint16

  # --- COMMENTED OUT: Load timing periods (reg 13003-13010), Load power optimized (13012-13015), Optimized power (13016) ---
  # - name: Load timing period 1 start hour
  #   unique_id: load_timing_period_1_start_hour
  #   address: 13002
  #   input_type: holding
  #   data_type: uint16
  # (... 13003-13009 for start/end minute, etc.)
  # - name: Optimized power of load
  #   unique_id: optimized_power_of_load
  #   address: 13015
  #   input_type: holding
  #   data_type: uint16

  # --- COMMENTED OUT: Charge Cutoff Voltage (33041), Forced Charging (33207-33218), Load Rated Power (33273) ---
  # - name: Charge Cutoff Voltage raw
  #   unique_id: charge_cutoff_voltage_raw
  #   address: 33041
  #   input_type: holding
  #   data_type: uint16
  #   scale: 0.1
  # - name: Forced Charging raw
  #   unique_id: forced_charging_raw
  #   address: 33207
  #   input_type: holding
  #   data_type: uint16
  # - name: External EMS heartbeat raw
  #   unique_id: external_ems_heartbeat_raw
  #   address: 13079
  #   input_type: holding
  #   data_type: uint16
  # - name: Load Rated Power raw
  #   unique_id: load_rated_power_raw
  #   address: 33273
  #   input_type: holding
  #   data_type: uint16
  #   scale: 0.01

  # EMS Mode sensor
  - name: "EMS Mode"
    unique_id: "ems_mode_selection_raw"
    address: 13049
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 10
    # Appendix 6: Energy Management Mode
    map:
      0: "Self-consumption (default)"
      2: "Forced mode" # The inverter is devised to charge or discharge the battery with the charging and discharging power as much as practicable.
      3: "External EMS mode"
      4: "VPP"
    group: "PV_modes"

  # Battery control sensors
  - name: Battery forced charge discharge cmd raw
    unique_id: battery_forced_charge_discharge_cmd_raw
    address: 13050 # reg 13051
    input_type: holding
    data_type: uint16
    precision: 0
    state_class: measurement
    scan_interval: 10
    # Parameter Setting Table 4: Charge/discharge command
    options:
      0xAA: "Charge"
      0xBB: "Discharge"
      0xCC: "Stop"
    group: "PV_battery_control"
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Battery forced charge discharge power raw
    unique_id: battery_forced_charge_discharge_power_raw
    address: 13051 # reg 13052
    input_type: holding
    data_type: uint16
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scan_interval: 10
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Global mpp scan manual raw
    unique_id: global_mpp_scan_manual_raw
    address: 30229 # reg 30230
    input_type: holding
    data_type: uint16
    precision: 0
    state_class: measurement
    scan_interval: 10

  # mkaiser issue #444 SH10RT no standby mode after latest firmware update
  - name: Forced Startup Under Low SoC Standby raw
    unique_id: forced_startup_under_low_soc_standby_raw
    address: 13016 # reg 13017 (Holding register - read-only for display purposes)
    input_type: holding
    data_type: uint16
    precision: 0
    state_class: measurement
    scan_interval: 10
    options:
      0x55: "Disabled"
      0xAA: "Enabled"
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

# Controls for write access
controls:
  - type: "select"
    name: "Inverter Run Mode"
    unique_id: "inverter_run_mode"
    address: 12999 # reg 13000
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 10
    # Parameter Setting Table 4: Start/Stop - 0xCF=Boot, 0xCE=Shutdown
    options:
      0xCF: "Enabled"
      0xCE: "Shutdown"
    group: "PV_control"
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - type: "select"
    name: "EMS Mode Selection"
    unique_id: "ems_mode_selection"
    address: 13049
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    # Appendix 6: Energy Management Mode
    options:
      0: "Self-consumption mode (default)"
      2: "Forced mode"
      3: "External EMS"
      4: "VPP"
    group: "PV_modes"
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - type: "select"
    name: "Battery forced charge discharge cmd"
    unique_id: "battery_forced_charge_discharge_cmd"
    address: 13050
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 10
    options:
      0xAA: "Charge"
      0xBB: "Discharge"
      0xCC: "Stop"
    group: "PV_battery_control"
    condition: "battery_enabled == true and meter_type in ['DTSU666', 'DTSU666-20']"

  - name: Battery forced charge discharge power
    unique_id: battery_forced_charge_discharge_power
    type: "number"
    address: 13051 # reg 13052
    input_type: holding
    data_type: uint16
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    min_value: 0
    max_value: "{{max(max_charge_power, max_discharge_power)}}"
    step: 100
    scan_interval: 10
    group: "PV_battery_control"
    condition: "battery_enabled == true and meter_type in ['DTSU666', 'DTSU666-20']"
    # Placeholder will be replaced with maximum of model-specific max_charge_power and max_discharge_power
    # For SH10RT: max(10600, 10600) = 10600 W

  - type: "select"
    name: "Load Adjustment Mode"
    unique_id: "load_adjustment_mode_selection"
    address: 13001
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    # Appendix 5: Load Control Mode
    options:
      0: "Timing mode"
      1: "ON/OFF mode"
      2: "Power optimized"
      3: "Disable"
    group: "PV_modes"

  - type: "number"
    name: "Max SoC"
    unique_id: "max_soc"
    address: 13057
    input_type: "holding"
    data_type: "uint16"
    scale: 0.1
    precision: 1
    unit_of_measurement: "%"
    min_value: 50
    max_value: 100
    step: 1
    scan_interval: 30
    group: "PV_battery_control"

  - type: "number"
    name: "Min SoC"
    unique_id: "min_soc"
    address: 13058
    input_type: "holding"
    data_type: "uint16"
    scale: 0.1
    precision: 1
    unit_of_measurement: "%"
    min_value: 0
    max_value: 50
    step: 1
    scan_interval: 30
    group: "PV_battery_control"

  - type: "select"
    name: "Backup Mode"
    unique_id: "backup_mode"
    address: 13074
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "Disabled"
      0xAA: "Enabled"
    group: "PV_modes"
    condition: "battery_enabled == true"

  - type: "number"
    name: "Export Power Limit"
    unique_id: "export_power_limit"
    address: 13073
    input_type: "holding"
    data_type: "uint16"
    precision: 0
    unit_of_measurement: "W"
    scale: 1
    min_value: 0
    max_value: "{{max_ac_output_power}}"
    step: 100
    mode: "box"  # Explicitly set to box for consistent UI display
    scan_interval: 30
    group: "PV_control"
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - type: "select"
    name: "Export Power Limit Mode"
    unique_id: "export_power_limit_mode"
    address: 13086
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "Disabled"
      0xAA: "Enabled"
    group: "PV_modes"
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - type: "number"
    name: "Export Power Limit Ratio"
    unique_id: "export_power_limit_ratio"
    address: 13087 # reg 13088 - Protocol V1.1.7
    input_type: "holding"
    data_type: "uint16"
    precision: 1
    unit_of_measurement: "%"
    scale: 0.1
    min_value: 0
    max_value: 1000
    step: 1
    mode: "box"  # Explicitly set to box for consistent UI display
    scan_interval: 30
    group: "PV_control"
    condition: "meter_type in ['DTSU666', 'DTSU666-20']"

  - type: "select"
    name: "Active Power Limitation"
    unique_id: "active_power_limitation"
    address: 13088 # reg 13089
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "Disabled"
      0xAA: "Enabled"
    group: "PV_control"

  - type: "number"
    name: "Active Power Limit Ratio"
    unique_id: "active_power_limit_ratio"
    address: 13089 # reg 13090
    input_type: "holding"
    data_type: "uint16"
    precision: 1
    unit_of_measurement: "%"
    scale: 0.1
    min_value: 0
    max_value: 1000
    step: 1
    scan_interval: 30
    group: "PV_control"

  - type: "number"
    name: "Reserved SoC for Backup"
    unique_id: "reserved_soc_for_backup"
    address: 13099
    input_type: "holding"
    data_type: "uint16"
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 1
    scan_interval: 30
    group: "PV_battery_control"

  - type: "select"
    name: "Load Adjustment Mode ON/OFF"
    unique_id: "load_adjustment_mode_on_off_selection"
    address: 13010
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    # Parameter Setting Table 4: Load ON/OFF mode
    options:
      0x55: "OFF"
      0xAA: "ON"
    group: "PV_modes"

  - type: "number"
    name: "Battery Max Charging Power"
    unique_id: "battery_max_charging_power"
    address: 33046 # reg 33047
    input_type: "holding"
    data_type: "uint16"
    precision: 2
    unit_of_measurement: "kW"
    scale: 0.01
    min_value: 0
    max_value: "{{max_charge_power}}"
    step: 0.01
    scan_interval: 10
    group: "PV_battery_control"
    # Placeholder will be replaced with model-specific value from dynamic_config.valid_models
    # For SH10RT: 10600 W -> 10.6 kW

  - type: "number"
    name: "Battery Max Discharging Power"
    unique_id: "battery_max_discharging_power"
    address: 33047 # reg 33048 - Protocol V1.1.11
    input_type: "holding"
    data_type: "uint16"
    precision: 2
    unit_of_measurement: "kW"
    scale: 0.01
    min_value: 0
    max_value: "{{max_discharge_power}}"
    step: 0.01
    scan_interval: 10
    group: "PV_battery_control"
    # Placeholder will be replaced with model-specific value from dynamic_config.valid_models
    # For SH10RT: 10600 W -> 10.6 kW

  - type: "number"
    name: "Export Power Limit Value Wide Range"
    unique_id: "export_power_limit_value_wide_range"
    address: 31221 # reg 31222 - Protocol V1.1.7
    input_type: "holding"
    data_type: "uint16"
    precision: 2
    unit_of_measurement: "kW"
    scale: 0.01
    min_value: 0
    max_value: "{{max_ac_output_power}}"
    step: 0.01
    mode: "box"  # Explicitly set to box for consistent UI display
    scan_interval: 30
    group: "PV_control"
    # Placeholder will be replaced with model-specific value from dynamic_config.valid_models
    # For SH10RT: 10000 W -> 10.0 kW

  - type: "number"
    name: "Battery Charging Start Power"
    unique_id: "battery_charging_start_power"
    address: 33148
    input_type: "holding"
    data_type: "uint16"
    precision: 0
    unit_of_measurement: "W"
    min_value: 0
    max_value: "{{max_charge_power * 0.5}}"
    step: 10
    device_class: "power"
    state_class: measurement
    scale: 10
    scan_interval: 10
    group: "PV_battery_control"
    # Placeholder will be replaced with 50% of model-specific max_charge_power
    # For SH10RT: 10600 * 0.5 = 5300 W

  - type: "number"
    name: "Battery Discharging Start Power"
    unique_id: "battery_discharging_start_power"
    address: 33149
    input_type: "holding"
    data_type: "uint16"
    precision: 0
    unit_of_measurement: "W"
    min_value: 0
    max_value: "{{max_discharge_power * 0.5}}"
    step: 10
    device_class: "power"
    state_class: measurement
    scale: 10
    scan_interval: 10
    group: "PV_battery_control"
    # Placeholder will be replaced with 50% of model-specific max_discharge_power
    # For SH10RT: 10600 * 0.5 = 5300 W

  - type: "select"
    name: "Forced Startup Under Low SoC Standby"
    unique_id: "forced_startup_under_low_soc_standby"
    address: 13016 # reg 13017 - Protocol V1.1.7 (Control register, not sensor)
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "Disabled"
      0xAA: "Enabled"
    group: "PV_control"
    condition: "battery_enabled == true"

  - type: "select"
    name: "PV Power Limitation"
    unique_id: "pv_power_limitation"
    address: 13017 # reg 13018 - Protocol V1.1.10
    condition: "selected_model in [SH5T, SH6T, SH8T, SH10T, SH12T, SH15T, SH20T, SH25T]"
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "Disabled"
      0xAA: "Limit PV"
    group: "PV_control"

# Calculated Sensors
calculated:
  # Net Grid Power
  - name: "Net Grid Power"
    unique_id: "net_grid_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
      }}
    state: >-
      {{ states('sensor.{PREFIX}_meter_active_power_raw') | float(0) }}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_grid_power"

  - name: "Import Power"
    unique_id: "import_power"
    type: "sensor"
    availability: "{{ not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable') }}"
    state: >-
      {% set export_power = states('sensor.{PREFIX}_export_power_raw') %}
      {% if export_power in ['unknown', 'unavailable', 'none'] or export_power is none %}
        0
      {% elif (export_power|int) < 0 %}
        {{ (export_power|int) * -1 }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_grid_power"

  - name: "Export Power"
    unique_id: "export_power"
    type: "sensor"
    availability: "{{states('sensor.{PREFIX}_export_power_raw')|is_number }}"
    state: >-
      {% if states('sensor.{PREFIX}_export_power_raw')|int > 0 %}
        {{ states('sensor.{PREFIX}_export_power_raw') }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_grid_power"

  - name: "Total Load Power"
    unique_id: "total_load_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_load_power', 'unavailable') }}
    state: "{{ states('sensor.{PREFIX}_load_power') | float(0) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_load_power"

  # Real load from energy flow balance: Load = PV + Import + Battery_Discharge - Export - Battery_Charge
  - name: "Real Load Power"
    unique_id: "real_load_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_import_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power', 'unavailable')
      }}
    state: >-
      {{
        (states('sensor.{PREFIX}_total_dc_power') | float(0))
        + (states('sensor.{PREFIX}_import_power') | float(0))
        + (states('sensor.{PREFIX}_battery_discharging_power') | float(0))
        - (states('sensor.{PREFIX}_export_power') | float(0))
        - (states('sensor.{PREFIX}_battery_charging_power') | float(0))
      }}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_load_power"

  # System Efficiency Calculations
  - name: "Solar to Grid Efficiency"
    unique_id: "solar_to_grid_efficiency"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
      }}
    state: >-
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set grid = states('sensor.{PREFIX}_meter_active_power_raw') | float(0) %}
      {% if pv > 0 and grid < 0 %}{{ (grid | abs / pv * 100) | round(1) }}{% else %}0{% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 1
    group: "PV_efficiency"

  - name: "Battery to Load Efficiency"
    unique_id: "battery_to_load_efficiency"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_pv_generation', 'unavailable')
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      }}
    state: "{% set pv = states('sensor.{PREFIX}_total_pv_generation') | float(0) %}{% set load = states('sensor.{PREFIX}_load_power') | float(0) %}{% if pv > 0 %}{{ (load / pv * 100) | round(1) }}{% else %}0{% endif %}"
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 1
    group: "PV_efficiency"

  # Power Balance Calculations
  - name: "Power Balance"
    unique_id: "power_balance"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      }}
    state: >-
      {% set grid = states('sensor.{PREFIX}_meter_active_power_raw') | float(0) %}
      {{ (states('sensor.{PREFIX}_total_dc_power') | float(0)) + (states('sensor.{PREFIX}_battery_power') | float(0)) + grid - (states('sensor.{PREFIX}_load_power') | float(0)) }}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_power_balance"

  # Phase Power Calculations
  - name: "Total Phase Power"
    unique_id: "total_phase_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_phase_a_active_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_meter_phase_b_active_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_meter_phase_c_active_power_raw', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_meter_phase_a_active_power_raw') | float(0)) + (states('sensor.{PREFIX}_meter_phase_b_active_power_raw') | float(0)) + (states('sensor.{PREFIX}_meter_phase_c_active_power_raw') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_phase_power"

  # Individual Phase Power Calculations
  - name: "Phase A Power"
    unique_id: "phase_a_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_phase_a_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_phase_a_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_a_voltage') | float(0)) * (states('sensor.{PREFIX}_phase_a_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_phase_power"

  - name: "Phase B Power"
    unique_id: "phase_b_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_phase_b_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_phase_b_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_b_voltage') | float(0)) * (states('sensor.{PREFIX}_phase_b_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_phase_power"

  - name: "Phase C Power"
    unique_id: "phase_c_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_phase_c_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_phase_c_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_c_voltage') | float(0)) * (states('sensor.{PREFIX}_phase_c_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_phase_power"

  # calculated sensor in case the meter is not available (grid is off) and returns 0x7FFFFF
  # For DTSU666 and DTSU666-20
  - name: "Meter Active Power"
    unique_id: "meter_active_power"
    type: "sensor"
    condition: "meter_type == 'DTSU666' or meter_type == 'DTSU666-20'"
    availability: >-
          {{
          not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
          and states('sensor.{PREFIX}_meter_active_power_raw')|int(0) != 0x7FFFFFFF
          }}
    state: "{{ states('sensor.{PREFIX}_meter_active_power_raw') }}"
    unit_of_measurement: "W"
    precision: 0
    device_class: "power"
    state_class: "measurement"

  # For DTSU666 and DTSU666-20
  - name: "Meter Phase A Active Power"
    unique_id: "meter_phase_a_active_power"
    type: "sensor"
    condition: "(meter_type == 'DTSU666' or meter_type == 'DTSU666-20') and phases > 1"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_phase_a_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_phase_a_active_power_raw')|int(0) != 0x7FFFFFFF
      }}
    state: >-
      {% set phase_a_power = states('sensor.{PREFIX}_meter_phase_a_active_power_raw') | float(0) %}
      {% if phase_a_power != 0x7FFFFFFF and phase_a_power != 2147483647 %}
        {{ phase_a_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    precision: 0
    state_class: "measurement"
    group: "PV_meter_power"

  - name: "Meter Phase B Active Power"
    unique_id: "meter_phase_b_active_power"
    type: "sensor"
    condition: "(meter_type == 'DTSU666' or meter_type == 'DTSU666-20') and phases > 1"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_phase_b_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_phase_b_active_power_raw')|int(0) != 0x7FFFFFFF
      }}
    state: >-
      {% set phase_b_power = states('sensor.{PREFIX}_meter_phase_b_active_power_raw') | float(0) %}
      {% if phase_b_power != 0x7FFFFFFF and phase_b_power != 2147483647 %}
        {{ phase_b_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_meter_power"

  - name: "Meter Phase C Active Power"
    unique_id: "meter_phase_c_active_power"
    type: "sensor"
    condition: "(meter_type == 'DTSU666' or meter_type == 'DTSU666-20') and phases > 1"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_phase_c_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_phase_c_active_power_raw')|int(0) != 0x7FFFFFFF
      }}
    state: >-
      {% set phase_c_power = states('sensor.{PREFIX}_meter_phase_c_active_power_raw') | float(0) %}
      {% if phase_c_power != 0x7FFFFFFF and phase_c_power != 2147483647 %}
        {{ phase_c_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_meter_power"

  # Meter Channel 2 Calculated Sensors (Protocol V1.1.11)
  # NOTE: These calculated sensors depend on the raw sensors, which are only registered when DTSU666-20 is selected
  - name: "Meter Channel 2 Total Active Power"
    unique_id: "meter_channel_2_total_active_power"
    type: "sensor"
    condition: "meter_type == 'DTSU666-20'"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_channel_2_total_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_channel_2_total_active_power_raw')|int(0) != 0x7FFFFFFF
      }}
    state: >-
      {% set channel_2_total_power = states('sensor.{PREFIX}_meter_channel_2_total_active_power_raw') | float(0) %}
      {% if channel_2_total_power != 0x7FFFFFFF and channel_2_total_power != 2147483647 %}
        {{ channel_2_total_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_meter_channel_2"

  - name: "Meter Channel 2 Phase A Active Power"
    unique_id: "meter_channel_2_phase_a_active_power"
    type: "sensor"
    condition: "meter_type == 'DTSU666-20'"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_channel_2_phase_a_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_channel_2_phase_a_active_power_raw')|int(0) != 0x7FFFFFFF
      }}
    state: >-
      {% set channel_2_phase_a_power = states('sensor.{PREFIX}_meter_channel_2_phase_a_active_power_raw') | float(0) %}
      {% if channel_2_phase_a_power != 0x7FFFFFFF and channel_2_phase_a_power != 2147483647 %}
        {{ channel_2_phase_a_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_meter_channel_2"

  - name: "Meter Channel 2 Phase B Active Power"
    unique_id: "meter_channel_2_phase_b_active_power"
    type: "sensor"
    condition: "meter_type == 'DTSU666-20'"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_channel_2_phase_b_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_channel_2_phase_b_active_power_raw')|int(0) != 0x7FFFFFFF
      }}
    state: >-
      {% set channel_2_phase_b_power = states('sensor.{PREFIX}_meter_channel_2_phase_b_active_power_raw') | float(0) %}
      {% if channel_2_phase_b_power != 0x7FFFFFFF and channel_2_phase_b_power != 2147483647 %}
        {{ channel_2_phase_b_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_meter_channel_2"

  - name: "Meter Channel 2 Phase C Active Power"
    unique_id: "meter_channel_2_phase_c_active_power"
    type: "sensor"
    condition: "meter_type == 'DTSU666-20'"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_meter_channel_2_phase_c_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_channel_2_phase_c_active_power_raw')|int(0) != 0x7FFFFFFF
      }}
    state: >-
      {% set channel_2_phase_c_power = states('sensor.{PREFIX}_meter_channel_2_phase_c_active_power_raw') | float(0) %}
      {% if channel_2_phase_c_power != 0x7FFFFFFF and channel_2_phase_c_power != 2147483647 %}
        {{ channel_2_phase_c_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_meter_channel_2"

  # Calculated Energy Summary Sensors
  - name: "Monthly PV generation (current)"
    unique_id: "monthly_pv_generation_current"
    type: "sensor"
    availability: >-
      {% set currMonth = 'monthly_pv_generation_' ~ '%0.2d' % now().month ~ '_' ~ now().timestamp() | timestamp_custom('%B') | lower %}
      {{ states('sensor.{PREFIX}_' ~ currMonth)|is_number }}
    state: >
      {% set currMonth = 'monthly_pv_generation_' ~ '%0.2d' % now().month ~ '_' ~ now().timestamp() | timestamp_custom('%B') | lower %}
      {{ states('sensor.{PREFIX}_' ~ currMonth) }}
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total_increasing"
    precision: 1
    condition: "connection_type == 'LAN'"
    group: "calculated_energy"

  - name: "Yearly PV generation (current)"
    unique_id: "yearly_pv_generation_current"
    type: "sensor"
    availability: >-
      {% set currYear = 'yearly_pv_generation_' ~ now().year %}
      {{ states('sensor.{PREFIX}_' ~ currYear)|is_number }}
    state: >
      {% set currYear = 'yearly_pv_generation_' ~ now().year %}
      {{ states('sensor.{PREFIX}_' ~ currYear) }}
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total_increasing"
    precision: 1
    condition: "connection_type == 'LAN'"
    group: "calculated_energy"

  - name: "Monthly export (current)"
    unique_id: "monthly_export_current"
    type: "sensor"
    availability: >-
      {% set currMonth = 'monthly_export_' ~ '%0.2d' % now().month ~ '_' ~ now().timestamp() | timestamp_custom('%B') | lower %}
      {{ states('sensor.{PREFIX}_' ~ currMonth)|is_number }}
    state: >
      {% set currMonth = 'monthly_export_' ~ '%0.2d' % now().month ~ '_' ~ now().timestamp() | timestamp_custom('%B') | lower %}
      {{ states('sensor.{PREFIX}_' ~ currMonth) }}
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total_increasing"
    precision: 1
    condition: "connection_type == 'LAN'"
    group: "calculated_energy"

  - name: "Yearly export (current)"
    unique_id: "yearly_export_current"
    type: "sensor"
    availability: >-
      {% set currYear = 'yearly_export_' ~ now().year %}
      {{ states('sensor.{PREFIX}_' ~ currYear)|is_number }}
    state: >
      {% set currYear = 'yearly_export_' ~ now().year %}
      {{ states('sensor.{PREFIX}_' ~ currYear) }}
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total_increasing"
    precision: 1
    condition: "connection_type == 'LAN'"
    group: "calculated_energy"

  # Battery Level and Charge Calculations
  - name: "Battery level (nominal)"
    unique_id: "battery_level_nom"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_battery_level', 'unavailable')
      and not is_state('number.{PREFIX}_min_soc', 'unavailable')
      and not is_state('number.{PREFIX}_max_soc', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_level', 'unknown')
      and not is_state('number.{PREFIX}_min_soc', 'unknown')
      and not is_state('number.{PREFIX}_max_soc', 'unknown')
      }}
    state: >-
      {% set soc_min = states('number.{PREFIX}_min_soc') | float %}
      {% set soc_max = states('number.{PREFIX}_max_soc') | float %}
      {% set soc_cur = states('sensor.{PREFIX}_battery_level') | float %}
      {{
        (soc_min + ((soc_max - soc_min) * (soc_cur / 100))) | round(1)
      }}
    unit_of_measurement: "%"
    device_class: "battery"
    state_class: "measurement"
    precision: 1
    group: "battery_level_nominal"

  - name: "Battery charge (nominal)"
    unique_id: "battery_charge_nom"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_battery_capacity', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_level_nominal', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_capacity', 'unknown')
      and not is_state('sensor.{PREFIX}_battery_level_nominal', 'unknown')
      }}
    state: >-
      {{
        ( states('sensor.{PREFIX}_battery_capacity') | float *
        states('sensor.{PREFIX}_battery_level_nominal') | float / 100 )| round(1)
      }}
    unit_of_measurement: "kWh"
    device_class: "energy_storage"
    state_class: "measurement"
    precision: 1
    group: "battery_charge_nominal"

  - name: "Battery charge"
    unique_id: "battery_charge"
    type: "sensor"
    unit_of_measurement: kWh
    device_class: energy_storage
    state_class: measurement
    precision: 2
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_battery_capacity', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_level', 'unavailable')
      and not is_state('number.{PREFIX}_min_soc', 'unavailable')
      and not is_state('number.{PREFIX}_max_soc', 'unavailable')
      }}
    state: >-
      {{
        ( states('sensor.{PREFIX}_battery_capacity')|float
        * ( states('number.{PREFIX}_max_soc')|float - states('number.{PREFIX}_min_soc')|float ) /100
        * states('sensor.{PREFIX}_battery_level')|float /100
        ) |round(2)
      }}
    group: "battery_charge"
    icon: "mdi:battery-charging-30"

  - name: "Battery charge (health-rated)"
    unique_id: "battery_charge_health_rated"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_battery_charge', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_state_of_health', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_charge', 'unknown')
      and not is_state('sensor.{PREFIX}_battery_state_of_health', 'unknown')
      }}
    state: >-
      {{
        ( states('sensor.{PREFIX}_battery_charge')|float
        * states('sensor.{PREFIX}_battery_state_of_health')|float / 100
        ) |round(2)
      }}
    unit_of_measurement: "kWh"
    device_class: "energy_storage"
    state_class: "measurement"
    precision: 2
    group: "battery_charge_health_rated"

  # Energy Consumption Calculations
  - name: "Daily consumed energy"
    unique_id: "daily_consumed_energy"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_daily_pv_generation', 'unavailable')
      and not is_state('sensor.{PREFIX}_daily_exported_energy', 'unavailable')
      and not is_state('sensor.{PREFIX}_daily_imported_energy', 'unavailable')
      and not is_state('sensor.{PREFIX}_daily_battery_charge', 'unavailable')
      and not is_state('sensor.{PREFIX}_daily_battery_discharge', 'unavailable')
      }}
    state: >-
      {{
        (
          states('sensor.{PREFIX}_daily_pv_generation')|float
          - states('sensor.{PREFIX}_daily_exported_energy')|float
          + states('sensor.{PREFIX}_daily_imported_energy')|float
          - states('sensor.{PREFIX}_daily_battery_charge')|float
          + states('sensor.{PREFIX}_daily_battery_discharge')|float
        )
      }}
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total"
    precision: 1
    group: "calculated_energy"

  - name: "Total consumed energy"
    unique_id: "total_consumed_energy"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_pv_generation', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_exported_energy', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_imported_energy', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_battery_charge', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_battery_discharge', 'unavailable')
      }}
    state: >-
      {{
        (
          states('sensor.{PREFIX}_total_pv_generation')|float
          - states('sensor.{PREFIX}_total_exported_energy')|float
          + states('sensor.{PREFIX}_total_imported_energy')|float
          - states('sensor.{PREFIX}_total_battery_charge')|float
          + states('sensor.{PREFIX}_total_battery_discharge')|float
        )
      }}
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total"
    precision: 1
    group: "calculated_energy"

  # Power Flow Calculations
  - name: "Signed battery power"
    unique_id: "signed_battery_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('binary_sensor.{PREFIX}_battery_charging', 'unavailable')
      and not is_state('binary_sensor.{PREFIX}_battery_discharging', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      }}
    state: >-
      {% if is_state('binary_sensor.{PREFIX}_battery_charging', 'on') %}
        {{ (states('sensor.{PREFIX}_battery_power') |float |abs)}}
      {% elif is_state('binary_sensor.{PREFIX}_battery_discharging', 'on') %}
        {{ (states('sensor.{PREFIX}_battery_power') |float |abs * -1)}}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "battery_power_signed"

  - name: "Battery charging power"
    unique_id: "battery_charging_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('binary_sensor.{PREFIX}_battery_charging', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      }}
    state: >-
      {% if is_state('binary_sensor.{PREFIX}_battery_charging', 'on') %}
        {{ states('sensor.{PREFIX}_battery_power')|int |abs }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "battery_power_charging"

  - name: "Battery discharging power"
    unique_id: "battery_discharging_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('binary_sensor.{PREFIX}_battery_discharging', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      }}
    state: >-
      {% if is_state('binary_sensor.{PREFIX}_battery_discharging', 'on') %}
        {{ states('sensor.{PREFIX}_battery_power')|int |abs }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "battery_power_discharging"

  # HA Energy Dashboard compatible sensors
  # These sensors follow HA Energy Dashboard convention:
  # - Positive values = consumption/discharging/import
  # - Negative values = generation/charging/export
  # Battery Power Sensors for HA Energy Dashboard
  # Note: battery_power is already in the correct format:
  # - Negative when charging (battery receives power)
  # - Positive when discharging (battery provides power)
  # This matches HA Energy Dashboard convention exactly

  - name: "Battery charging power signed"
    unique_id: "battery_charging_power_signed"
    type: "sensor"
    availability: "{{ states('sensor.{PREFIX}_battery_power') not in ['unknown','unavailable'] }}"
    state: "{{ states('sensor.{PREFIX}_battery_power')|int * -1 }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "battery_power_energy_dashboard"
    # Note: battery_power is negative when charging, so we multiply by -1 to get positive when charging
    # This is useful for display purposes (showing positive charging power)

  - name: "Battery discharging power signed"
    unique_id: "battery_discharging_power_signed"
    type: "sensor"
    availability: "{{ states('sensor.{PREFIX}_battery_power') not in ['unknown','unavailable'] }}"
    state: "{{ states('sensor.{PREFIX}_battery_power')|int }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "battery_power_energy_dashboard"
    # Note: battery_power is positive when discharging, which matches HA Energy Dashboard convention
    # Use this sensor for the HA energy dashboard.
    # HA Energy Dashboard configuration description:
    # "Pick a sensor which measures the electricity flowing into and out of the battery in either of GW, kW, MW, mW, TW, W.
    # Positive values indicate discharging the battery, negative values indicate charging the battery."
    # IMPORTANT: For HA Energy Dashboard, use sensor.{PREFIX}_battery_power directly (it already has the correct sign)

  # Grid Power Sensors for HA Energy Dashboard
  # Note: export_power_raw format:
  # - Positive when exporting to grid (generation)
  # - Negative when importing from grid (consumption)
  # For HA Energy Dashboard, we need:
  # - Negative when exporting (generation)
  # - Positive when importing (consumption)
  # So we need to invert the sign of export_power_raw

  - name: "Grid power signed"
    unique_id: "grid_power_signed"
    type: "sensor"
    availability: "{{ states('sensor.{PREFIX}_export_power_raw') not in ['unknown','unavailable'] }}"
    state: "{{ states('sensor.{PREFIX}_export_power_raw')|int * -1 }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "grid_power_energy_dashboard"
    # Note: export_power_raw is positive when exporting, so we multiply by -1
    # Result: Negative when exporting (generation), Positive when importing (consumption)
    # IMPORTANT: Use this sensor for HA Energy Dashboard grid power
    # HA Energy Dashboard: Positive = consumption (import), Negative = generation (export)

  - name: "Grid export power signed"
    unique_id: "grid_export_power_signed"
    type: "sensor"
    availability: "{{ states('sensor.{PREFIX}_export_power_raw') not in ['unknown','unavailable'] }}"
    state: >-
      {% set export_power = states('sensor.{PREFIX}_export_power_raw')|int %}
      {% if export_power > 0 %}
        {{ export_power * -1 }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "grid_power_energy_dashboard"
    # Note: export_power_raw is positive when exporting, so we multiply by -1 for HA Energy Dashboard
    # Negative values = export to grid (generation)
    # This shows only export power as negative values

  - name: "Grid import power signed"
    unique_id: "grid_import_power_signed"
    type: "sensor"
    availability: "{{ states('sensor.{PREFIX}_export_power_raw') not in ['unknown','unavailable'] }}"
    state: >-
      {% set export_power = states('sensor.{PREFIX}_export_power_raw')|int %}
      {% if export_power < 0 %}
        {{ export_power * -1 }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "grid_power_energy_dashboard"
    # Note: export_power_raw is negative when importing, so we multiply by -1 to get positive
    # Positive values = import from grid (consumption)
    # This shows only import power as positive values

  # PV Analysis & Performance Metrics
  # Self-Consumption and Autarky Calculations
  - name: "Self-Consumption Rate"
    unique_id: "self_consumption_rate"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_discharging_power', 'unavailable')
      }}
    state: >-
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set export_raw = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set battery_discharge = states('sensor.{PREFIX}_battery_discharging_power') | float(0) %}
      {% if pv <= 0 %}
        {# No PV generation #}
        0
      {% else %}
        {# Eigenverbrauch = total_dc_power - export_power_raw + battery_discharging_power #}
        {# export_power_raw: positive = export, negative = import (don't subtract import) #}
        {% set exported = export_raw if export_raw > 0 else 0 %}
        {% set self_consumed = pv - exported + battery_discharge %}
        {% if self_consumed <= 0 %}
          0
        {% else %}
          {% set rate = (self_consumed / pv * 100) %}
          {# Clamp to 0-100% range #}
          {% if rate > 100 %}
            100
          {% elif rate < 0 %}
            0
          {% else %}
            {{ rate | round(1) }}
          {% endif %}
        {% endif %}
      {% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 1
    group: "PV_analysis"
    # Percentage of PV generation that is consumed directly (not exported to grid)

  - name: "Autarky Rate"
    unique_id: "autarky_rate"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_discharging_power', 'unavailable')
      }}
    state: >-
      {% set load = states('sensor.{PREFIX}_load_power') | float(0) %}
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set export_raw = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set battery_discharge = states('sensor.{PREFIX}_battery_discharging_power') | float(0) %}
      {% if load <= 0 %}
        {# No load or negative load - 100% autarky #}
        100
      {% else %}
        {# Eigenverbrauch = total_dc_power - export_power_raw + battery_discharging_power #}
        {# export_power_raw: positive = export (subtract), negative = import (don't subtract) #}
        {% set exported = export_raw if export_raw > 0 else 0 %}
        {% set self_consumed = pv - exported + battery_discharge %}
        {# Autarkiegrad (%) = (Eigenverbrauch / Gesamtverbrauch) * 100 #}
        {% if self_consumed <= 0 %}
          0
        {% else %}
          {% set autarky = (self_consumed / load * 100) %}
          {# Clamp to 0-100% range #}
          {% if autarky > 100 %}
            100
          {% elif autarky < 0 %}
            0
          {% else %}
            {{ autarky | round(1) }}
          {% endif %}
        {% endif %}
      {% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 2
    group: "PV_analysis"
    # Percentage of load that is supplied by PV/Battery (self-sufficiency)

  # Self-Consumption Rate (Today)
  # Self-Consumption Rate = (Direct + PVâBattery) / PV Generation Ã 100
  - name: "Self-Consumption Rate (Today)"
    unique_id: "self_consumption_rate_today"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_daily_direct_energy_consumption', 'unavailable')
      and not is_state('sensor.{PREFIX}_daily_pv_generation', 'unavailable')
      }}
    state: >-
      {% set direct = states('sensor.{PREFIX}_daily_direct_energy_consumption') | float(0) %}
      {% set pv_to_battery = states('sensor.{PREFIX}_daily_battery_charge_from_pv') | float(0) %}
      {% set pv_gen = states('sensor.{PREFIX}_daily_pv_generation') | float(0) %}
      {% if pv_gen <= 0 %}
        0
      {% else %}
        {% set self_consumed = direct + pv_to_battery %}
        {% set rate = (self_consumed / pv_gen * 100) %}
        {% if rate > 100 %}100{% elif rate < 0 %}0{% else %}{{ rate | round(1) }}{% endif %}
      {% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 1
    group: "PV_analysis"
    # (Direct consumption + PV to battery) / PV generation Ã 100

  # Autarky Rate (Today) â standard formula per Klarsolar/GitHub Pages
  # Autarkiegrad = (Direct + Battery discharge) / Total consumption Ã 100
  # "Welcher Anteil des verbrauchten Stroms stammt aus eigener Produktion (inkl. Speicher)?"
  - name: "Autarky Rate (Today)"
    unique_id: "autarky_rate_today"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_daily_direct_energy_consumption', 'unavailable')
      and not is_state('sensor.{PREFIX}_daily_consumed_energy', 'unavailable')
      }}
    state: >-
      {% set direct = states('sensor.{PREFIX}_daily_direct_energy_consumption') | float(0) %}
      {% set battery_discharge = states('sensor.{PREFIX}_daily_battery_discharge') | float(0) %}
      {% set consumed = states('sensor.{PREFIX}_daily_consumed_energy') | float(0) %}
      {% if consumed <= 0 %}
        100
      {% else %}
        {% set self_supplied = direct + battery_discharge %}
        {% set autarky = (self_supplied / consumed * 100) %}
        {% if autarky > 100 %}100{% elif autarky < 0 %}0{% else %}{{ autarky | round(1) }}{% endif %}
      {% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 1
    group: "PV_analysis"
    # (Direct consumption + Battery discharge) / Total consumption Ã 100

  # DC to AC Conversion Efficiency
#  - name: "DC to AC Efficiency"
#    unique_id: "dc_to_ac_efficiency"
#    type: "sensor"
#    availability: >-
#      {{
#      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
#      and not is_state('sensor.{PREFIX}_phase_a_power', 'unavailable')
#      and not is_state('sensor.{PREFIX}_phase_b_power', 'unavailable')
#      and not is_state('sensor.{PREFIX}_phase_c_power', 'unavailable')
#      }}
#    state: >-
#      {% set dc_power = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
#      {% set ac_power = (states('sensor.{PREFIX}_phase_a_power') | float(0)) + (states('sensor.{PREFIX}_phase_b_power') | float(0)) + (states('sensor.{PREFIX}_phase_c_power') | float(0)) %}
#      {% if dc_power > 0 %}
#        {{ ((ac_power / dc_power) * 100) | round(2) }}
#      {% else %}
#        0
#      {% endif %}
#    unit_of_measurement: "%"
#    device_class: "power_factor"
#    state_class: "measurement"
#    precision: 2
#    group: "PV_efficiency"
#    # Inverter efficiency: AC output power / DC input power
# DC â AC Conversion Efficiency (echte Sungrow PV-Effizienz)
  - name: "DC to AC Efficiency"
    unique_id: "dc_to_ac_efficiency"
    state: >-
      {% set dc = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set total_ac = states('sensor.{PREFIX}_total_active_power') | float(0) %}
      {% set batt = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set meter = states('sensor.{PREFIX}_meter_active_power') | float(0) %}

      {# Netzbezug positiv, Einspeisung negativ #}
      {% set grid_import = meter if meter > 0 else 0 %}

      {# PV-AC-Leistung rekonstruieren #}
      {% set pv_ac = total_ac - batt - grid_import %}

      {# Nur gÃ¼ltig wenn PV wirklich produziert #}
      {% if dc > 0 and pv_ac > 0 %}
        {{ ((pv_ac / dc) * 100) | round(2) }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "%"
    device_class: power_factor
    state_class: measurement
    precision: 2
    icon: mdi:solar-power

  # MPPT Power Calculations (Voltage * Current for each MPPT)
  - name: "MPPT1 Power"
    unique_id: "mppt1_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt1_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt1_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt1_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt1_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_mppt_power"

  - name: "MPPT2 Power"
    unique_id: "mppt2_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt2_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt2_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt2_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt2_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_mppt_power"

  - name: "MPPT3 Power"
    unique_id: "mppt3_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt3_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt3_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt3_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt3_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_mppt_power"

  - name: "MPPT4 Power"
    unique_id: "mppt4_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt4_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt4_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt4_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt4_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_mppt_power"

  # Total MPPT Power (sum of all MPPT trackers)
  - name: "Total MPPT Power"
    unique_id: "total_mppt_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt1_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt2_power', 'unavailable')
      }}
    state: >-
      {{
        (states('sensor.{PREFIX}_mppt1_power') | float(0) ) +
        (states('sensor.{PREFIX}_mppt2_power') | float(0) ) +
        (states('sensor.{PREFIX}_mppt3_power') | float(0) ) +
        (states('sensor.{PREFIX}_mppt4_power') | float(0) )
      }}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_mppt_power"
    # Sum of all MPPT tracker powers (should match total_dc_power)

  # Energy Flow Analysis
  - name: "PV to Load Direct"
    unique_id: "pv_to_load_direct"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      }}
    state: >-
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set load = states('sensor.{PREFIX}_load_power') | float(0) %}
      {% set export = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set battery = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set exported = export if export > 0 else 0 %}
      {% set charging = (battery | abs) if battery < 0 else 0 %}
      {% set discharging = battery if battery > 0 else 0 %}
      {% set grid_import = (export | abs) if export < 0 else 0 %}
      {% set load_deficit = [load - pv - discharging, 0] | max %}
      {% set grid_to_load = [grid_import, load_deficit] | min %}
      {% set grid_to_batt = [grid_import - grid_to_load, charging] | min %}
      {% set pv_to_batt = charging - grid_to_batt %}
      {% set pv_available = pv - exported - pv_to_batt %}
      {% if pv_available > 0 and load > 0 %}
        {{ [pv_available, load] | min }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_energy_flow"
    # PV power going directly to load (without battery)

  - name: "PV to Battery"
    unique_id: "pv_to_battery"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      }}
    state: >-
      {% set battery = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set grid_raw = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set load = states('sensor.{PREFIX}_load_power') | float(0) %}
      {% set charging = (battery | abs) if battery < 0 else 0 %}
      {% set discharging = battery if battery > 0 else 0 %}
      {% set grid_import = (grid_raw | abs) if grid_raw < 0 else 0 %}
      {% if charging > 0 %}
        {% set load_deficit = [load - pv - discharging, 0] | max %}
        {% set grid_to_load = [grid_import, load_deficit] | min %}
        {% set grid_to_batt = [grid_import - grid_to_load, charging] | min %}
        {{ charging - grid_to_batt }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_energy_flow"
    # PV (DC) charging battery; grid (ACâDC) only after load supplied

  - name: "Grid to Battery"
    unique_id: "grid_to_battery"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      }}
    state: >-
      {% set battery = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set grid_raw = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set load = states('sensor.{PREFIX}_load_power') | float(0) %}
      {% set charging = (battery | abs) if battery < 0 else 0 %}
      {% set discharging = battery if battery > 0 else 0 %}
      {% set grid_import = (grid_raw | abs) if grid_raw < 0 else 0 %}
      {% if grid_import > 0 and charging > 0 %}
        {# Grid supplies load first (AC path); only remainder charges battery (ACâDC) #}
        {% set load_deficit = [load - pv - discharging, 0] | max %}
        {% set grid_to_load = [grid_import, load_deficit] | min %}
        {{ [grid_import - grid_to_load, charging] | min }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_energy_flow"
    # Grid power charging battery; only after load is supplied (ACâDC conversion)

  - name: "Battery to Load"
    unique_id: "battery_to_load"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      }}
    state: >-
      {% set battery = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set export = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set discharging = battery if battery > 0 else 0 %}
      {% set grid_export = export if export > 0 else 0 %}
      {% if discharging > 0 %}
        {% set battery_to_grid = [grid_export, discharging] | min %}
        {{ discharging - battery_to_grid }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_energy_flow"
    # Battery power going to load; excludes battery-to-grid portion

  - name: "PV to Grid"
    unique_id: "pv_to_grid"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      }}
    state: >-
      {% set export = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set battery = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set discharging = battery if battery > 0 else 0 %}
      {% if export > 0 %}
        {% set battery_to_grid = [export, discharging] | min %}
        {{ export - battery_to_grid }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_energy_flow"
    # PV excess power exported to grid; excludes battery-to-grid portion

  - name: "Battery to Grid"
    unique_id: "battery_to_grid"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      }}
    state: >-
      {% set export = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set battery = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set discharging = battery if battery > 0 else 0 %}
      {% if export > 0 and discharging > 0 %}
        {{ [export, discharging] | min }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_energy_flow"
    # Battery power exported to grid (e.g. VPP, feed-in when PV insufficient)

  - name: "Grid to Load"
    unique_id: "grid_to_load"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      }}
    state: >-
      {% set grid_raw = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set battery = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set load = states('sensor.{PREFIX}_load_power') | float(0) %}
      {% set grid_import = (grid_raw | abs) if grid_raw < 0 else 0 %}
      {% set discharging = battery if battery > 0 else 0 %}
      {% if grid_import > 0 %}
        {# Grid supplies load first (AC); remainder may charge battery #}
        {% set load_deficit = [load - pv - discharging, 0] | max %}
        {{ [grid_import, load_deficit] | min }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_energy_flow"
    # Grid power to load (priority); battery charging only from remaining import

  - name: "Net Consumption"
    unique_id: "net_consumption"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
      }}
    state: >-
      {% set load = states('sensor.{PREFIX}_load_power') | float(0) %}
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set battery = states('sensor.{PREFIX}_battery_power') | float(0) %}
      {% set battery_supply = battery if battery > 0 else 0 %}
      {% set net = load - pv - battery_supply %}
      {{ net if net > 0 else 0 }}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 0
    group: "PV_analysis"
    # Net consumption after PV and battery supply (what needs to come from grid)

  - name: "Grid Dependency"
    unique_id: "grid_dependency"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_discharging_power', 'unavailable')
      }}
    state: >-
      {% set load = states('sensor.{PREFIX}_load_power') | float(0) %}
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set export_raw = states('sensor.{PREFIX}_export_power_raw') | float(0) %}
      {% set battery_discharge = states('sensor.{PREFIX}_battery_discharging_power') | float(0) %}
      {% if load <= 0 %}
        {# No load or negative load - 0% grid dependency #}
        0
      {% else %}
        {# Eigenverbrauch = total_dc_power - export_power_raw + battery_discharging_power #}
        {% set exported = export_raw if export_raw > 0 else 0 %}
        {% set self_consumed = pv - exported + battery_discharge %}
        {# Grid Dependency = (Import / Gesamtverbrauch) * 100 = ((load - self_consumed) / load) * 100 #}
        {% set import_power = load - self_consumed %}
        {% if import_power <= 0 %}
          {# No import needed - 0% grid dependency #}
          0
        {% else %}
          {% set dependency = (import_power / load * 100) %}
          {# Clamp to 0-100% range #}
          {% if dependency > 100 %}
            100
          {% elif dependency < 0 %}
            0
          {% else %}
            {{ dependency | round(1) }}
          {% endif %}
        {% endif %}
      {% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 2
    group: "PV_analysis"
    # Percentage of load that depends on grid (inverse of autarky)

  # MPPT Performance Analysis
  - name: "MPPT Deviation from Average"
    unique_id: "mppt_power_deviation"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt1_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt2_power', 'unavailable')
      }}
    state: >-
      {% set m1 = states('sensor.{PREFIX}_mppt1_power') | float(0) %}
      {% set m2 = states('sensor.{PREFIX}_mppt2_power') | float(0) %}
      {% set m3 = states('sensor.{PREFIX}_mppt3_power') | float(0) %}
      {% set m4 = states('sensor.{PREFIX}_mppt4_power') | float(0) %}
      {% set powers = [m1, m2, m3, m4] | select('>', 0) | list %}
      {% if powers | length > 0 %}
        {% set avg = (powers | sum) / (powers | length) %}
        {% set ns = namespace(max_dev=0) %}
        {% for p in powers %}
          {% set dev = (p - avg) | abs %}
          {% if dev > ns.max_dev %}
            {% set ns.max_dev = dev %}
          {% endif %}
        {% endfor %}
        {{ ns.max_dev | round(1) }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    precision: 1
    group: "PV_mppt_analysis"
    # Maximum deviation from average MPPT power (W); indicates string imbalance

  - name: "MPPT Balance"
    unique_id: "mppt_balance"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt_power_deviation', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_mppt_power', 'unavailable')
      }}
    state: >-
      {% set deviation = states('sensor.{PREFIX}_mppt_power_deviation') | float(0) %}
      {% set total = states('sensor.{PREFIX}_total_mppt_power') | float(0) %}
      {% if total > 0 %}
        {{ [100 - (deviation / total * 100), 0] | max | round(1) }}
      {% else %}
        100
      {% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 1
    group: "PV_mppt_analysis"
    # 100% = perfectly balanced strings; lower = one string underperforming

  - name: "Active MPPT Count"
    unique_id: "active_mppt_count"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt1_power', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt2_power', 'unavailable')
      }}
    state: >-
      {% set m1 = states('sensor.{PREFIX}_mppt1_power') | float(0) %}
      {% set m2 = states('sensor.{PREFIX}_mppt2_power') | float(0) %}
      {% set m3 = states('sensor.{PREFIX}_mppt3_power') | float(0) %}
      {% set m4 = states('sensor.{PREFIX}_mppt4_power') | float(0) %}
      {{ ([m1, m2, m3, m4] | select('>', 10) | list | length) }}
    unit_of_measurement: ""
    state_class: "measurement"
    precision: 0
    group: "PV_mppt_analysis"
    # Number of MPPT channels with power > 10 W (avoids noise); useful for 4-MPPT inverters with fewer strings

  # PV System Performance Metrics
  - name: "PV Capacity Factor"
    unique_id: "pv_capacity_factor"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      }}
    state: >-
      {% set current_power = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set device_type = states('sensor.{PREFIX}_sungrow_device_type_code') | default('') %}
      {% set max_power = 5000 %}
      {% if 'SH3.0' in device_type or 'SH3K' in device_type %}
        {% set max_power = 3000 %}
      {% elif 'SH3.6' in device_type %}
        {% set max_power = 3600 %}
      {% elif 'SH4.0' in device_type %}
        {% set max_power = 4000 %}
      {% elif 'SH5.0' in device_type %}
        {% set max_power = 5000 %}
      {% elif 'SH6.0' in device_type %}
        {% set max_power = 6000 %}
      {% elif 'SH8.0' in device_type %}
        {% set max_power = 8000 %}
      {% elif 'SH10' in device_type %}
        {% set max_power = 10000 %}
      {% endif %}
      {% if max_power > 0 %}
        {{ (current_power / max_power * 100) | round(1) }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    precision: 1
    group: "PV_performance"
    # Current PV power as percentage of inverter rated capacity

  - name: "PV Generation Hours Today"
    unique_id: "pv_generation_hours_today"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_daily_pv_generation', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      }}
    state: >-
      {% set daily_gen = states('sensor.{PREFIX}_daily_pv_generation') | float(0) %}
      {% set current_power = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set avg_power = current_power %}
      {% if avg_power > 0 %}
        {{ (daily_gen / avg_power) | round(2) }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "h"
    device_class: "duration"
    state_class: "measurement"
    precision: 2
    group: "PV_performance"
    # Equivalent generation hours at current power level (approximation)

  # Protocol Version (formatted) - extracts directly from raw value using bit operations
  # Format per documentation V1.1.7: 0xMMmmppbb
  - name: "Protocol Version"
    unique_id: "protocol_version"
    type: "sensor"
    availability: "{{ not is_state('sensor.{PREFIX}_protocol_version_raw', 'unavailable') }}"
    state: >-
      {% set raw_value = states('sensor.{PREFIX}_protocol_version_raw') %}
      {% if raw_value in ['unavailable', 'unknown', 'None', ''] %}
        unknown
      {% else %}
        {% set raw = raw_value | int %}
        {% set major = (raw // 16777216) %}
        {% set minor = (raw // 65536) % 256 %}
        {% set patch = (raw // 256) % 256 %}
        {% set build = raw % 256 %}
        {% set raw = raw | int %}
        V{{ major }}.{{ minor }}.{{ patch }}
      {% endif %}
    icon: "mdi:code-tags"
    group: "PV_device_info"
    entity_category: "diagnostic"

  ## some additional calculated sensors ideas
  - name: "Inverter Status Display"
    unique_id: "inverter_status_display"
    type: "sensor"
    state: >-
      {% set power = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set temp = states('sensor.{PREFIX}_inverter_temperature') | float(0) %}
      {% set device_type = states('sensor.{PREFIX}_sungrow_device_type_code') %}

      {# Extract power rating from device type code #}
      {% set inverter_power = 5000 %}  {# Default fallback #}
      {% if device_type is defined and device_type != 'unknown' and device_type != 'unavailable' %}
        {% if 'SH3.0' in device_type or 'SH3K' in device_type %}
          {% set inverter_power = 3000 %}
        {% elif 'SH3.6' in device_type %}
          {% set inverter_power = 3600 %}
        {% elif 'SH4.0' in device_type or 'SH4K' in device_type %}
          {% set inverter_power = 4000 %}
        {% elif 'SH5.0' in device_type or 'SH5K' in device_type or 'SH5T' in device_type %}
          {% set inverter_power = 5000 %}
        {% elif 'SH6.0' in device_type or 'SH6K' in device_type or 'SH6T' in device_type %}
          {% set inverter_power = 6000 %}
        {% elif 'SH7.0' in device_type %}
          {% set inverter_power = 7000 %}
        {% elif 'SH8.0' in device_type or 'SH8K' in device_type or 'SH8T' in device_type %}
          {% set inverter_power = 8000 %}
        {% elif 'SH10' in device_type or 'SH10T' in device_type %}
          {% set inverter_power = 10000 %}
        {% elif 'SH12' in device_type or 'SH12T' in device_type %}
          {% set inverter_power = 12000 %}
        {% elif 'SH15' in device_type or 'SH15T' in device_type %}
          {% set inverter_power = 15000 %}
        {% elif 'SH17' in device_type %}
          {% set inverter_power = 17000 %}
        {% elif 'SH20' in device_type or 'SH20T' in device_type %}
          {% set inverter_power = 20000 %}
        {% elif 'SH25' in device_type or 'SH25T' in device_type %}
          {% set inverter_power = 25000 %}
        {% elif 'MG5' in device_type %}
          {% set inverter_power = 5000 %}
        {% elif 'MG6' in device_type %}
          {% set inverter_power = 6000 %}
        {% endif %}
      {% endif %}

      {# Calculate percentage of rated power #}
      {% set power_percentage = (power / inverter_power * 100) if inverter_power > 0 else 0 %}

      {% if power_percentage >= 80 %}
        High Production ({{ power_percentage | round(0) }}%)
      {% elif power_percentage >= 30 %}
        Normal Production ({{ power_percentage | round(0) }}%)
      {% elif power_percentage >= 5 %}
        Low Production ({{ power_percentage | round(0) }}%)
      {% else %}
        Standby
      {% endif %}
    icon_template: >-
      {% set power = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set temp = states('sensor.{PREFIX}_inverter_temperature') | float(0) %}
      {% set device_type = states('sensor.{PREFIX}_sungrow_device_type_code') %}

      {# Extract power rating from device type code #}
      {% set inverter_power = 5000 %}  {# Default fallback #}
      {% if device_type is defined and device_type != 'unknown' and device_type != 'unavailable' %}
        {% if 'SH3.0' in device_type or 'SH3K' in device_type %}
          {% set inverter_power = 3000 %}
        {% elif 'SH3.6' in device_type %}
          {% set inverter_power = 3600 %}
        {% elif 'SH4.0' in device_type or 'SH4K' in device_type %}
          {% set inverter_power = 4000 %}
        {% elif 'SH5.0' in device_type or 'SH5K' in device_type or 'SH5T' in device_type %}
          {% set inverter_power = 5000 %}
        {% elif 'SH6.0' in device_type or 'SH6K' in device_type or 'SH6T' in device_type %}
          {% set inverter_power = 6000 %}
        {% elif 'SH7.0' in device_type %}
          {% set inverter_power = 7000 %}
        {% elif 'SH8.0' in device_type or 'SH8K' in device_type or 'SH8T' in device_type %}
          {% set inverter_power = 8000 %}
        {% elif 'SH10' in device_type or 'SH10T' in device_type %}
          {% set inverter_power = 10000 %}
        {% elif 'SH12' in device_type or 'SH12T' in device_type %}
          {% set inverter_power = 12000 %}
        {% elif 'SH15' in device_type or 'SH15T' in device_type %}
          {% set inverter_power = 15000 %}
        {% elif 'SH17' in device_type %}
          {% set inverter_power = 17000 %}
        {% elif 'SH20' in device_type or 'SH20T' in device_type %}
          {% set inverter_power = 20000 %}
        {% elif 'SH25' in device_type or 'SH25T' in device_type %}
          {% set inverter_power = 25000 %}
        {% elif 'MG5' in device_type %}
          {% set inverter_power = 5000 %}
        {% elif 'MG6' in device_type %}
          {% set inverter_power = 6000 %}
        {% endif %}
      {% endif %}

      {# Calculate percentage of rated power #}
      {% set power_percentage = (power / inverter_power * 100) if inverter_power > 0 else 0 %}

      {% if temp > 70 %}
        mdi:alert-circle
      {% elif power_percentage >= 80 %}
        mdi:solar-power
      {% elif power_percentage >= 30 %}
        mdi:solar-panel
      {% elif power_percentage >= 5 %}
        mdi:solar-panel-large
      {% else %}
        mdi:power-sleep
      {% endif %}
    group: "PV_status"

  - name: "Grid Status"
    unique_id: "grid_status"
    type: "sensor"
    state: >-
      {% set import_power = states('sensor.{PREFIX}_meter_active_power') | float(0) %}
      {% if import_power > 100 %}
        Importing
      {% elif import_power < -100 %}
        Exporting
      {% else %}
        Balanced
      {% endif %}
    icon_template: >-
      {% set import_power = states('sensor.{PREFIX}_meter_active_power') | float(0) %}
      {% if import_power > 500 %}
        mdi:transmission-tower-import
      {% elif import_power > 100 %}
        mdi:transmission-tower
      {% elif import_power < -500 %}
        mdi:transmission-tower-export
      {% elif import_power < -100 %}
        mdi:transmission-tower-off
      {% else %}
        mdi:scale-balance
      {% endif %}
    group: "PV_grid_status"

  - name: "Battery Status Indicator"
    unique_id: "battery_status_indicator"
    type: "sensor"
    state: >-
      {% set soc = states('sensor.{PREFIX}_battery_level') | float(0) %}
      {% set power = states('sensor.{PREFIX}_signed_battery_power') | float(0) %}
      {% if power > 100 %}
        Charging
      {% elif power < -100 %}
        Discharging
      {% else %}
        Idle
      {% endif %}
    icon_template: >-
      {% set soc = states('sensor.{PREFIX}_battery_level') | float(0) %}
      {% set power = states('sensor.{PREFIX}_signed_battery_power') | float(0) %}
      {% if power > 100 %}
        {% if soc > 90 %}
          mdi:battery-charging
        {% elif soc > 75 %}
          mdi:battery-charging-80
        {% elif soc > 50 %}
          mdi:battery-charging-60
        {% elif soc > 25 %}
          mdi:battery-charging-40
        {% else %}
          mdi:battery-charging-20
        {% endif %}
      {% elif power < -100 %}
        {% if soc > 75 %}
          mdi:battery-minus
        {% elif soc > 50 %}
          mdi:battery-60
        {% elif soc > 25 %}
          mdi:battery-40
        {% else %}
          mdi:battery-20
        {% endif %}
      {% else %}
        {% if soc > 90 %}
          mdi:battery
        {% elif soc > 75 %}
          mdi:battery-80
        {% elif soc > 50 %}
          mdi:battery-60
        {% elif soc > 25 %}
          mdi:battery-40
        {% elif soc > 10 %}
          mdi:battery-20
        {% else %}
          mdi:battery-outline
        {% endif %}
      {% endif %}
    group: "battery_status"


  - name: "Battery Health Status"
    unique_id: "battery_health_status"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_battery_state_of_health', 'unavailable')
      and not is_state('sensor.{PREFIX}_battery_state_of_health', 'unknown')
      }}
    state: >-
      {% set soh = states('sensor.{PREFIX}_battery_state_of_health') | float(0) %}
      {% if soh >= 90 %}
        Excellent
      {% elif soh >= 80 %}
        Good
      {% elif soh >= 70 %}
        Fair
      {% elif soh >= 60 %}
        Poor
      {% else %}
        Critical
      {% endif %}
    icon_template: >-
      {% set soh = states('sensor.{PREFIX}_battery_state_of_health') | float(0) %}
      {% if soh >= 90 %}
        mdi:battery
      {% elif soh >= 80 %}
        mdi:battery-80
      {% elif soh >= 70 %}
        mdi:battery-60
      {% elif soh >= 60 %}
        mdi:battery-40
      {% else %}
        mdi:battery-alert
      {% endif %}
    group: "battery_health_status"

# Binary Sensors
binary_sensors:
  # Binary Sensors for Status Monitoring
  - name: "PV generating"
    unique_id: "pv_generating"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int |bitwise_and(0x1)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set total_dc_power = states('sensor.{PREFIX}_total_dc_power') %}
        {% if total_dc_power in ['unknown', 'unavailable', 'none'] or total_dc_power is none %}
          0
        {% elif (total_dc_power|int) > 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"

  - name: "PV generating (delay)"
    unique_id: "pv_generating_delay"
    type: "binary_sensor"
    availability: "{{ not is_state('binary_sensor.{PREFIX}_pv_generating', 'unavailable') }}"
    delay_on:
      seconds: 60
    state: "{{ states('binary_sensor.{PREFIX}_pv_generating') }}"
    device_class: "power"
    group: "PV_binary_status"

  - name: "Battery charging"
    unique_id: "battery_charging"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      or
        (   not is_state('sensor.{PREFIX}_ems_mode_selection_raw', 'unavailable')
        and not is_state('sensor.{PREFIX}_battery_forced_charge_discharge_cmd_raw', 'unavailable')
        and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
        and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
        and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
        )
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {% if (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x2)) > 0 %}
          on
        {% else %}
          off
        {% endif %}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% if (states('sensor.{PREFIX}_ems_mode_selection') ) in ["Forced mode", "VPP"] %}
          {# EMS forced mode #}
          {% if (states('sensor.{PREFIX}_battery_forced_charge_discharge_cmd') == "Forced charge") %}
            {# in mode Forced charge #}
            {% if (states('sensor.{PREFIX}_battery_power')|int > 0 ) %}
              {# power flow from/to battery #}
              on
            {% else %}
              {# no power flow from/to battery #}
              off
            {% endif %}
          {% else %}
            {# in EMS mode, but not in mode Forced charge #}
            off
          {% endif %}
        {% else %}
          {# not in EMS forced mode, assuming self consumption mode #}
          {% set total_dc_power = states('sensor.{PREFIX}_total_dc_power') %}
          {% set load_power = states('sensor.{PREFIX}_load_power') %}
          {% if (total_dc_power in ['unknown', 'unavailable', 'none'] or total_dc_power is none) or (load_power in ['unknown', 'unavailable', 'none'] or load_power is none) %}
            off
          {% elif (total_dc_power|int) > (load_power|int) %}
            {# more power generated than consumed. assuming battery charging #}
            on
          {% else %}
            off
          {% endif %}
        {% endif %}
      {% endif %}
    device_class: "battery_charging"
    group: "PV_binary_status"

  - name: "Battery charging (delay)"
    unique_id: "battery_charging_delay"
    type: "binary_sensor"
    availability: "{{ not is_state('binary_sensor.{PREFIX}_battery_charging', 'unavailable') }}"
    delay_on:
      seconds: 60
    state: "{{ states('binary_sensor.{PREFIX}_battery_charging') }}"
    device_class: "battery_charging"
    group: "PV_binary_status"

  - name: "Battery discharging"
    unique_id: "battery_discharging"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      or
        (   not is_state('sensor.{PREFIX}_ems_mode_selection_raw', 'unavailable')
        and not is_state('sensor.{PREFIX}_battery_forced_charge_discharge_cmd_raw', 'unavailable')
        and not is_state('sensor.{PREFIX}_battery_power', 'unavailable')
        and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
        and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
        )
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {% if (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x4)) > 0 %}
          on
        {% else %}
          off
        {% endif %}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% if (states('sensor.{PREFIX}_ems_mode_selection') ) in ["Forced mode", "VPP"] %}
          {# EMS forced mode #}
          {% if (states('sensor.{PREFIX}_battery_forced_charge_discharge_cmd') == "Forced discharge") %}
            {# in mode Forced discharge #}
            {% if (states('sensor.{PREFIX}_battery_power')|int > 0 ) %}
              {# power flow from/to battery #}
              on
            {% else %}
              {# no power flow from/to battery #}
              off
            {% endif %}
          {% else %}
            {# in EMS mode, but not in mode Forced charge #}
            off
          {% endif %}
        {% else %}
          {# not in EMS forced mode, assuming self consumption mode #}
          {% set total_dc_power = states('sensor.{PREFIX}_total_dc_power') %}
          {% set load_power = states('sensor.{PREFIX}_load_power') %}
          {% set battery_power = states('sensor.{PREFIX}_battery_power') %}
          {% if ( (total_dc_power in ['unknown', 'unavailable', 'none'] or total_dc_power is none) or (load_power in ['unknown', 'unavailable', 'none'] or load_power is none) or (battery_power in ['unknown', 'unavailable', 'none'] or battery_power is none) ) %}
            off
          {% elif ( (total_dc_power|int < load_power|int) ) and (battery_power|int) > 0 %}
            {# more power consumed than generated and some battery power --> assuming battery discharging #}
            on
          {% else %}
            off
          {% endif %}
        {% endif %}
      {% endif %}
    group: "PV_binary_status"

  - name: "Battery discharging (delay)"
    unique_id: "battery_discharging_delay"
    type: "binary_sensor"
    availability: "{{ not is_state('binary_sensor.{PREFIX}_battery_discharging', 'unavailable') }}"
    delay_on:
      seconds: 60
    state: "{{ states('binary_sensor.{PREFIX}_battery_discharging') }}"
    group: "PV_binary_status"

  - name: "Exporting power"
    unique_id: "exporting_power"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x10)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set export_power = states('sensor.{PREFIX}_export_power_raw') %}
        {% if export_power in ['unknown', 'unavailable', 'none'] or export_power is none %}
          0
        {% elif (export_power|int) > 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"

  - name: "Exporting power (delay)"
    unique_id: "exporting_power_delay"
    type: "binary_sensor"
    availability: "{{ not is_state('binary_sensor.{PREFIX}_exporting_power', 'unavailable') }}"
    delay_on:
      seconds: 60
    state: "{{ states('binary_sensor.{PREFIX}_exporting_power') }}"
    device_class: "power"
    group: "PV_binary_status"

  - name: "Importing power"
    unique_id: "importing_power"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      and not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x20)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set export_power = states('sensor.{PREFIX}_export_power_raw') %}
        {% if export_power in ['unknown', 'unavailable', 'none'] or export_power is none %}
          0
        {% elif (export_power|int) < 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"

  - name: "Importing power (delay)"
    unique_id: "importing_power_delay"
    type: "binary_sensor"
    availability: "{{ not is_state('binary_sensor.{PREFIX}_importing_power', 'unavailable') }}"
    delay_on:
      seconds: 60
    state: "{{ states('binary_sensor.{PREFIX}_importing_power') }}"
    device_class: "power"
    group: "PV_binary_status"

  - name: "Positive load power"
    unique_id: "positive_load_power"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x8)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set load_power = states('sensor.{PREFIX}_load_power') %}
        {% if load_power in ['unknown', 'unavailable', 'none'] or load_power is none %}
          0
        {% elif (load_power|int) > 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"

  - name: "Negative load power"
    unique_id: "negative_load_power"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x80)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set load_power = states('sensor.{PREFIX}_load_power') %}
        {% if load_power in ['unknown', 'unavailable', 'none'] or load_power is none %}
          0
        {% elif (load_power|int) < 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"
